This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.github/workflows/dev-deploy.yml
.github/workflows/prod-deploy.yml
.gitignore
.roo/mcp.json
ala-dev.bat
azure/azure-deploy.sh
azure/deploy.ps1
azure/README.md
backend/Dockerfile
backend/Dockerfile.dev
backend/package.json
backend/src/config/database.ts
backend/src/controllers/applicatorController.ts
backend/src/controllers/authController.ts
backend/src/controllers/priorityController.ts
backend/src/controllers/treatmentController.ts
backend/src/dbInit.ts
backend/src/middleware/authMiddleware.ts
backend/src/middleware/errorMiddleware.ts
backend/src/middleware/notFoundMiddleware.ts
backend/src/models/Applicator.ts
backend/src/models/index.ts
backend/src/models/Treatment.ts
backend/src/models/User.ts
backend/src/routes/adminRoutes.ts
backend/src/routes/applicatorRoutes.ts
backend/src/routes/authRoutes.ts
backend/src/routes/healthRoutes.ts
backend/src/routes/priorityRoutes.ts
backend/src/routes/treatmentRoutes.ts
backend/src/seedUser.js
backend/src/seedUser.ts
backend/src/server.ts
backend/src/services/applicatorService.ts
backend/src/services/mockPriorityService.ts
backend/src/services/priorityService.ts
backend/src/services/treatmentService.ts
backend/src/utils/logger.ts
backend/tsconfig.json
debug.sh
docker-compose.dev.yml
docker-compose.prod.yml
docs/ALA-GIT-GUIDE.md
docs/GIT-WORKFLOW.md
docs/IMPROVEMENTS.md
frontend/Dockerfile
frontend/Dockerfile.dev
frontend/index.html
frontend/nginx.conf
frontend/package.json
frontend/postcss.config.js
frontend/src/App.tsx
frontend/src/components/FileExplorer.tsx
frontend/src/components/Layout.tsx
frontend/src/components/ProtectedRoute.tsx
frontend/src/context/AuthContext.tsx
frontend/src/context/TreatmentContext.tsx
frontend/src/index.css
frontend/src/main.tsx
frontend/src/pages/Admin/Dashboard.tsx
frontend/src/pages/Auth/LoginPage.tsx
frontend/src/pages/Auth/VerificationPage.tsx
frontend/src/pages/ProjectDocPage.tsx
frontend/src/pages/Treatment/ApplicatorInformation.tsx
frontend/src/pages/Treatment/ScanQRCode.tsx
frontend/src/pages/Treatment/SeedRemoval.tsx
frontend/src/pages/Treatment/TreatmentSelection.tsx
frontend/src/pages/Treatment/UseList.tsx
frontend/src/services/api.ts
frontend/src/services/authService.ts
frontend/src/services/priorityService.ts
frontend/src/services/treatmentService.ts
frontend/tailwind.config.js
frontend/tsconfig.json
frontend/tsconfig.node.json
frontend/vite.config.ts
GITHUB-README.md
memory-bank/activeContext.md
memory-bank/decisionLog.md
memory-bank/memory-bank/.git/config
memory-bank/memory-bank/.git/description
memory-bank/memory-bank/.git/HEAD
memory-bank/memory-bank/.git/hooks/applypatch-msg.sample
memory-bank/memory-bank/.git/hooks/commit-msg.sample
memory-bank/memory-bank/.git/hooks/fsmonitor-watchman.sample
memory-bank/memory-bank/.git/hooks/post-update.sample
memory-bank/memory-bank/.git/hooks/pre-applypatch.sample
memory-bank/memory-bank/.git/hooks/pre-commit.sample
memory-bank/memory-bank/.git/hooks/pre-merge-commit.sample
memory-bank/memory-bank/.git/hooks/pre-push.sample
memory-bank/memory-bank/.git/hooks/pre-rebase.sample
memory-bank/memory-bank/.git/hooks/pre-receive.sample
memory-bank/memory-bank/.git/hooks/prepare-commit-msg.sample
memory-bank/memory-bank/.git/hooks/push-to-checkout.sample
memory-bank/memory-bank/.git/hooks/sendemail-validate.sample
memory-bank/memory-bank/.git/hooks/update.sample
memory-bank/memory-bank/.git/info/exclude
memory-bank/memory-bank/.git/packed-refs
memory-bank/memory-bank/.git/refs/heads/main
memory-bank/memory-bank/.git/refs/remotes/origin/HEAD
memory-bank/memory-bank/.gitignore
memory-bank/memory-bank/docs/clinerules.md
memory-bank/memory-bank/docs/README.md
memory-bank/memory-bank/package.json
memory-bank/memory-bank/README.md
memory-bank/memory-bank/src/index.ts
memory-bank/memory-bank/tsconfig.json
memory-bank/progress.md
memory-bank/projectContext.md
README.md
scripts/debug.js
scripts/new-feature.bat
scripts/new-feature.sh
scripts/new-hotfix.bat
scripts/new-hotfix.sh
scripts/release.bat
scripts/release.sh

================================================================
Files
================================================================

================
File: .roo/mcp.json
================
{
  "mcpServers": {}
}

================
File: backend/src/controllers/priorityController.ts
================
import { Request, Response } from 'express';
import asyncHandler from 'express-async-handler';
import logger from '../utils/logger';
import priorityService from '../services/priorityService';

// @desc    Validate user email against Priority PHONEBOOK
// @route   POST /api/proxy/priority/validate-email
// @access  Public
export const validateUserEmail = asyncHandler(async (req: Request, res: Response) => {
  const { email } = req.body;
  
  if (!email) {
    res.status(400);
    throw new Error('Email is required');
  }
  
  try {
    logger.info(`Validating email: ${email}`);
    
    // Check the email with Priority
    const priorityUserAccess = await priorityService.getUserSiteAccess(email);
    
    if (!priorityUserAccess.found) {
      logger.info(`Email ${email} not found in Priority system`);
      res.status(404).json({
        isValid: false,
        error: 'Email not found in the system'
      });
      return;
    }
    
    logger.info(`Email ${email} found in Priority system`);
    res.status(200).json({
      isValid: true,
      userData: {
        name: priorityUserAccess.user?.email || 'User',
        email: priorityUserAccess.user?.email || email,
        phoneNumber: priorityUserAccess.user?.phone || '',
        positionCode: priorityUserAccess.user?.positionCode || '',
        custName: priorityUserAccess.sites[0] || '',
      }
    });
  } catch (error: any) {
    logger.error(`Error validating email: ${error.message}`);
    res.status(500).json({
      isValid: false,
      error: `Error: ${error.message}`
    });
  }
});

// @desc    Debug Priority API connection
// @route   GET /api/proxy/priority/debug
// @access  Private
export const debugPriorityConnection = asyncHandler(async (req: Request, res: Response) => {
  try {
    // Use real connection test
    const result = await priorityService.debugPriorityConnection();
    
    res.status(200).json(result);
  } catch (error: any) {
    logger.error(`Debug error: ${error.message}`);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// @desc    Get treatments from Priority system
// @route   GET /api/proxy/priority/treatments
// @access  Private
export const getTreatments = asyncHandler(async (req: Request, res: Response) => {
  try {
    // Extract parameters from request query
    const { type, subjectId, site, date } = req.query;
    
    // Get user sites from request user metadata
    const userSites = req.user?.metadata?.sites || [];
    
    // Get treatments from Priority for user's sites
    const treatments = await priorityService.getTreatmentsForSites(
      userSites, 
      {
        type: type as string,
        subjectId: subjectId as string,
        site: site as string,
        date: date as string
      }
    );
    
    res.status(200).json(treatments);
  } catch (error: any) {
    logger.error(`Error fetching treatments: ${error.message}`);
    res.status(500).json({
      error: error.message
    });
  }
});

// @desc    Get all contacts from Priority PHONEBOOK
// @route   GET /api/proxy/priority/contacts
// @access  Private
export const getContacts = asyncHandler(async (req: Request, res: Response) => {
  try {
    // Get contacts directly from Priority
    const contacts = await priorityService.getContacts();
    
    res.status(200).json(contacts);
  } catch (error: any) {
    logger.error(`Error fetching contacts: ${error.message}`);
    res.status(500).json({
      error: error.message
    });
  }
});

// @desc    Get orders for a specific CUSTNAME (site)
// @route   GET /api/proxy/priority/orders
// @access  Private
export const getOrdersForSite = asyncHandler(async (req: Request, res: Response) => {
  try {
    const { custName } = req.query;
    
    if (!custName) {
      res.status(400).json({ 
        error: 'custName parameter is required'
      });
      return;
    }
    
    // Get orders for the specified site
    const orders = await priorityService.getOrdersForSite(custName as string);
    
    res.status(200).json(orders);
  } catch (error: any) {
    logger.error(`Error fetching orders: ${error.message}`);
    res.status(500).json({
      error: error.message
    });
  }
});

// @desc    Get allowed sites for user based on POSITIONCODE and CUSTNAME
// @route   GET /api/proxy/priority/allowed-sites
// @access  Private
export const getAllowedSitesForUser = asyncHandler(async (req: Request, res: Response) => {
  try {
    const { userPositionCode, userCustName } = req.query;
    
    if (!userPositionCode || !userCustName) {
      res.status(400).json({ 
        error: 'userPositionCode and userCustName parameters are required'
      });
      return;
    }
    
    // Get allowed sites for the user
    const sites = await priorityService.getAllowedSitesForUser(
      userPositionCode as string,
      userCustName as string
    );
    
    res.status(200).json(sites);
  } catch (error: any) {
    logger.error(`Error fetching allowed sites: ${error.message}`);
    res.status(500).json({
      error: error.message
    });
  }
});

================
File: backend/src/routes/priorityRoutes.ts
================
import express from 'express';
import {
  validateUserEmail,
  debugPriorityConnection,
  getTreatments,
  getContacts,
  getOrdersForSite,
  getAllowedSitesForUser
} from '../controllers/priorityController';
import { protect } from '../middleware/authMiddleware';

const router = express.Router();

// Public routes (no auth required)
router.post('/validate-email', validateUserEmail);

// Protected routes (auth required)
router.get('/debug', protect, debugPriorityConnection);
router.get('/treatments', protect, getTreatments);
router.get('/contacts', protect, getContacts);
router.get('/orders', protect, getOrdersForSite);
router.get('/allowed-sites', protect, getAllowedSitesForUser);

export default router;

================
File: backend/src/services/mockPriorityService.ts
================
import logger from '../utils/logger';

// This service provides mock data when real Priority API is unavailable
const mockPriorityService = {
  // Mock user data for testing
  getMockUserByEmail(email: string): any {
    logger.info(`Getting mock user data for email: ${email}`);
    
    // Demo users for testing
    const mockUsers = [
      {
        EMAIL: 'test@example.com',
        NAME: 'Test User',
        PHONE: '+972501234567',
        POSITIONCODE: '10',
        CUSTNAME: '100001'
      },
      {
        EMAIL: 'admin@example.com',
        NAME: 'Admin User',
        PHONE: '+972509876543',
        POSITIONCODE: '99',
        CUSTNAME: '100002'
      },
      {
        EMAIL: 'doctor@hospital.com',
        NAME: 'Doctor Smith',
        PHONE: '+972505555555',
        POSITIONCODE: '20',
        CUSTNAME: '100003'
      },
      {
        EMAIL: 'tzufitc@alphatau.com',
        NAME: 'TzufitC',
        PHONE: '971',
        POSITIONCODE: '99',
        CUSTNAME: '100078'
      }
    ];
    
    // Find the user by email (case-insensitive)
    return mockUsers.find(user => user.EMAIL.toLowerCase() === email.toLowerCase());
  },
  
  // Get mock PHONEBOOK data
  getMockContacts(): any[] {
    logger.info('Getting mock contacts data');
    
    return [
      {
        EMAIL: 'test@example.com',
        NAME: 'Test User',
        PHONE: '+972501234567',
        POSITIONCODE: '10',
        CUSTNAME: '100001',
        CUSTDES: 'Hospital A'
      },
      {
        EMAIL: 'admin@example.com',
        NAME: 'Admin User',
        PHONE: '+972509876543',
        POSITIONCODE: '99',
        CUSTNAME: '100002',
        CUSTDES: 'Admin Office'
      },
      {
        EMAIL: 'doctor@hospital.com',
        NAME: 'Doctor Smith',
        PHONE: '+972505555555',
        POSITIONCODE: '20',
        CUSTNAME: '100003',
        CUSTDES: 'Hospital C'
      },
      {
        EMAIL: 'nurse@hospital.com',
        NAME: 'Nurse Johnson',
        PHONE: '+972507777777',
        POSITIONCODE: '30',
        CUSTNAME: '100003',
        CUSTDES: 'Hospital C'
      },
      {
        EMAIL: 'tech@alphatau.com',
        NAME: 'Tech Support',
        PHONE: '+972508888888',
        POSITIONCODE: '40',
        CUSTNAME: '100004',
        CUSTDES: 'Alpha Tau'
      },
      {
        EMAIL: 'tzufitc@alphatau.com',
        NAME: 'TzufitC',
        PHONE: '971',
        POSITIONCODE: '99',
        CUSTNAME: '100078',
        CUSTDES: 'ATM'
      }
    ];
  },
  
  // Get mock ORDERS data
  getMockOrders(custName?: string): any[] {
    logger.info(`Getting mock orders data${custName ? ` for customer: ${custName}` : ''}`);
    
    const allOrders = [
      {
        ORDNAME: 'ORD001',
        CUSTNAME: '100001',
        CUSTDES: 'Hospital A',
        SIBD_TREATDAY: '2025-05-10',
        TYPEDES: 'Inert',
        BOOLCLOSED: 'N',
        SBD_APPLICATOR: '12345',
        TOTQUANT: 5
      },
      {
        ORDNAME: 'ORD002',
        CUSTNAME: '100001',
        CUSTDES: 'Hospital A',
        SIBD_TREATDAY: '2025-05-15',
        TYPEDES: 'Active',
        BOOLCLOSED: 'N',
        SBD_APPLICATOR: '67890',
        TOTQUANT: 3
      },
      {
        ORDNAME: 'ORD003',
        CUSTNAME: '100003',
        CUSTDES: 'Hospital C',
        SIBD_TREATDAY: '2025-05-12',
        TYPEDES: 'Inert',
        BOOLCLOSED: 'Y',
        SBD_APPLICATOR: '24680',
        TOTQUANT: 2
      },
      {
        ORDNAME: 'ORD004',
        CUSTNAME: '100004',
        CUSTDES: 'AlphaTau Office',
        SIBD_TREATDAY: '2025-05-20',
        TYPEDES: 'Inert',
        BOOLCLOSED: 'N',
        SBD_APPLICATOR: '13579',
        TOTQUANT: 10
      },
      {
        ORDNAME: 'ORD005',
        CUSTNAME: '100078',
        CUSTDES: 'ATM',
        SIBD_TREATDAY: '2025-05-17',
        TYPEDES: 'Inert',
        BOOLCLOSED: 'N',
        SBD_APPLICATOR: '54321',
        TOTQUANT: 7
      }
    ];
    
    if (!custName) {
      return allOrders;
    }
    
    return allOrders.filter(order => order.CUSTNAME === custName);
  }
};

export default mockPriorityService;

================
File: memory-bank/memory-bank/.git/config
================
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[remote "origin"]
	url = https://github.com/dazeb/cline-mcp-memory-bank.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main

================
File: memory-bank/memory-bank/.git/description
================
Unnamed repository; edit this file 'description' to name the repository.

================
File: memory-bank/memory-bank/.git/HEAD
================
ref: refs/heads/main

================
File: memory-bank/memory-bank/.git/hooks/applypatch-msg.sample
================
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:

================
File: memory-bank/memory-bank/.git/hooks/commit-msg.sample
================
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}

================
File: memory-bank/memory-bank/.git/hooks/fsmonitor-watchman.sample
================
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}

================
File: memory-bank/memory-bank/.git/hooks/post-update.sample
================
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info

================
File: memory-bank/memory-bank/.git/hooks/pre-applypatch.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:

================
File: memory-bank/memory-bank/.git/hooks/pre-commit.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --

================
File: memory-bank/memory-bank/.git/hooks/pre-merge-commit.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:

================
File: memory-bank/memory-bank/.git/hooks/pre-push.sample
================
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0

================
File: memory-bank/memory-bank/.git/hooks/pre-rebase.sample
================
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END

================
File: memory-bank/memory-bank/.git/hooks/pre-receive.sample
================
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi

================
File: memory-bank/memory-bank/.git/hooks/prepare-commit-msg.sample
================
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi

================
File: memory-bank/memory-bank/.git/hooks/push-to-checkout.sample
================
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi

================
File: memory-bank/memory-bank/.git/hooks/sendemail-validate.sample
================
#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi

================
File: memory-bank/memory-bank/.git/hooks/update.sample
================
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0

================
File: memory-bank/memory-bank/.git/info/exclude
================
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~

================
File: memory-bank/memory-bank/.git/packed-refs
================
# pack-refs with: peeled fully-peeled sorted 
c956fa692523e8a609407b3fbed4ba1a74a5d7e2 refs/remotes/origin/main
ba440309d83d5242b0fdb8dc5b2d481be7e55568 refs/remotes/origin/whitesource/configure

================
File: memory-bank/memory-bank/.git/refs/heads/main
================
c956fa692523e8a609407b3fbed4ba1a74a5d7e2

================
File: memory-bank/memory-bank/.git/refs/remotes/origin/HEAD
================
ref: refs/remotes/origin/main

================
File: memory-bank/memory-bank/.gitignore
================
node_modules/
build/
*.log
.env*

================
File: memory-bank/memory-bank/docs/clinerules.md
================
Memory Bank Integration Rules:

CRITICAL: Before ANY task or response:
1. ALWAYS check active context (memory://active/context):
   - Current project state and mode
   - Ongoing tasks and their status
   - Recent decisions and updates
   - Open questions and concerns

2. ALWAYS review project context (memory://project/context):
   - Technical stack and dependencies
   - Project guidelines and standards
   - Architecture principles
   - Development workflow

3. ALWAYS consult decision log (memory://decisions) for:
   - Previous architectural choices
   - Established patterns
   - Technical rationales
   - Related decisions

4. ALWAYS check progress tracking (memory://progress):
   - Current phase and milestones
   - Completed work
   - In-progress tasks
   - Known blockers

After EVERY task:
1. Update active context with:
   - Task completion status
   - New information learned
   - Changes made

2. Record any technical decisions with:
   - Clear rationale
   - Considered alternatives
   - Impact assessment

3. Update progress tracking:
   - Mark completed items
   - Add new tasks identified
   - Note any blockers found

Key Guidelines:
- NEVER proceed without checking memory bank context
- ALWAYS maintain consistent project state
- Record ALL significant technical decisions
- Track progress in real-time
- Keep context updated with EVERY change

================
File: memory-bank/memory-bank/docs/README.md
================
Add the contents of `.clinerules` to your system prompt of choice.

You can add it to your codebase as a `.clinerules` file or to your system prompt within Cline.

================
File: memory-bank/memory-bank/package.json
================
{
  "name": "memory-bank-server",
  "version": "0.1.0",
  "description": "MCP server for persistent project context management",
  "type": "module",
  "main": "build/index.js",
  "bin": {
    "memory-bank-server": "./build/index.js"
  },
  "scripts": {
    "build": "tsc && node -e \"require('fs').chmodSync('build/index.js', '755')\"",
    "watch": "tsc -w",
    "clean": "rm -rf build",
    "prepare": "npm run build"
  },
  "keywords": [
    "mcp",
    "model-context-protocol",
    "project-management",
    "context-management",
    "ai-development",
    "cline"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.8.0"
  },
  "devDependencies": {
    "@types/node": "^20.17.30",
    "typescript": "^5.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/your-username/memory-bank-server"
  },
  "engines": {
    "node": ">=16"
  },
  "packageManager": "pnpm@10.3.0+sha512.ee592eda8815a8a293c206bb0917c4bb0ff274c50def7cbc17be05ec641fc2d1b02490ce660061356bd0d126a4d7eb2ec8830e6959fb8a447571c631d5a2442d"
}

================
File: memory-bank/memory-bank/README.md
================
# Cline Memory Bank 

Inspired by [roo-code-memory-bank](https://github.com/GreatScottyMac/roo-code-memory-bank)

This project is **still in development** but is mostly working.

A Model Context Protocol server that provides persistent project context management for AI-assisted development - specifically designed to work with [Cline VSCode Extenson](https://marketplace.visualstudio.com/items?itemName=saoudrizwan.claude-dev).

## Table of Contents

- [Overview](#overview)
- [Installation](#installation)
  - [Prerequisites](#prerequisites)
  - [Setup Steps](#setup-steps)
- [Features](#features)
  - [Tools](#tools)
  - [Resources](#resources)
  - [System Prompt for Cline](#system-prompt-suggestion)
- [File Structure](#file-structure)
- [Using With Cline](#using-with-cline)
- [Development](#development)
- [Contributing](#contributing)
- [License](#license)

## Overview

The Memory Bank MCP server helps maintain consistent project context across development sessions by providing structured tools and resources for managing:

- Project context and technical details
- Current session state and tasks
- Progress tracking and milestones
- Technical decisions and rationale

```mermaid
graph LR
    VSCode[VS Code + Cline] --> MemBank[Memory Bank Server]
    MemBank --> Files[Markdown Files]
    Files --> Context[Project Context]
    Files --> Progress[Progress Tracking]
    Files --> Decisions[Decision Log]
    AI[AI Assistant] --> Files
    VSCode --> AI
    AI --> MemBank
```

## Persistent Memory System

One of the most powerful features of this project is its ability to maintain context across different coding sessions. Think of it as giving your AI assistant a "memory" that doesn't forget what you've been working on, even when you close VSCode and come back later.

### How It Works

Imagine you're working on a complex project that spans multiple days or weeks. Normally, each time you start a new coding session, you'd need to re-explain your project's context to the AI assistant. With the Memory Bank:

```mermaid
graph LR
    Session[New Session] --> Load[Load Context]
    Load --> Read[Read Files]
    Read --> Update[Update Context]
    Update --> Write[Write Changes]
    Write --> Track[Track Progress]
    Track --> Record[Record Decisions]
    Record --> Ready[Ready for Tasks]
```

- Your AI assistant remembers previous discussions and decisions
- Maintains understanding of your project's architecture and goals
- Keeps track of ongoing tasks and progress
- Remembers your coding preferences and project conventions

### Key Benefits

1. **Continuity Across Sessions**
   - No need to re-explain your project every time
   - Pick up exactly where you left off
   - Maintains consistent understanding of your codebase

2. **Smart Context Management**
   - Automatically tracks important technical decisions
   - Records project progress and milestones
   - Maintains documentation of your development journey

3. **Enhanced Productivity**
   - Faster project onboarding for each session
   - More consistent and contextual AI assistance
   - Reduces repetitive explanations

4. **Project History**
   - Keeps track of why certain decisions were made
   - Maintains a log of completed features and changes
   - Helps new team members understand project evolution

The Memory Bank seamlessly integrates with the Cline VSCode Extension, requiring no additional setup from you once configured. It works quietly in the background, ensuring your AI assistant always has the context it needs to provide relevant and helpful assistance.

## Installation

### Prerequisites

- Node.js (v16 or later)
- VS Code with Cline extension installed
- TypeScript (for development)

### Setup Steps

1. Clone and build the server:
```bash
# Clone the repository
git clone https://github.com/dazeb/cline-mcp-memory-bank
cd cline-mcp-memory-bank

# Install dependencies (using pnpm as recommended)
pnpm install

# Build the server
pnpm run build

# Make globally available (optional, requires pnpm setup for global linking)
# pnpm link --global 
```

2. Configure Cline Extension (Recommended: Use Initialization Command):

   **Recommended Method:** After building, run the initialization command from the project root. This automatically creates the memory bank files and configures the Cline MCP settings for you:
   ```bash
   node build/index.js initialize_memory_bank . 
   ```

   **Manual Method (If needed):** Add the following to your Cline MCP settings file. The path varies by OS:
   - **Linux:** `~/.config/Code - Insiders/User/globalStorage/saoudrizwan.claude-dev/settings/cline_mcp_settings.json`
   - **macOS:** `~/Library/Application Support/Code - Insiders/User/globalStorage/saoudrizwan.claude-dev/settings/cline_mcp_settings.json`
   - **Windows:** `%APPDATA%\Code - Insiders\User\globalStorage\saoudrizwan.claude-dev\settings\cline_mcp_settings.json`

   Add this JSON object:

```json
{
  "mcpServers": {
    "memory-bank": {
      "command": "node",
      "args": [
        "/path/to/cline-memory-bank/build/index.js"
      ],
      "disabled": false,
      "autoApprove": []
    }
  }
}
```

Replace `/path/to/cline-memory-bank` with the actual, absolute path to your server installation (e.g., `C:\Users\YourUser\Projects\cline-mcp-memory-bank` on Windows). **Note:** Using the initialization command above handles this automatically.

## Features

### Tools

After installation and building, initialize the memory bank for your project by running this command in the project's root directory:
```bash
node /path/to/cline-mcp-memory-bank/build/index.js initialize_memory_bank .
```
(Replace `/path/to/cline-mcp-memory-bank` with the actual path where you cloned and built the server).

Alternatively, if the server is configured in Cline, you can ask Cline to run the tool: `initialize the memory bank`.

Once initialized, you can ask Cline to update the memory bank context, record decisions, or track progress using the tools below, or configure it via `.clinerules` or the system prompt.

1. `initialize_memory_bank`
   - Creates Memory Bank structure for a new project
   - Creates required markdown files with initial templates
   ```typescript
   use_mcp_tool('memory-bank', 'initialize_memory_bank', {
     projectPath: '/path/to/project'
   });
   ```

2. `update_context`
   - Updates active context with current session information
   - Tracks mode, tasks, and session state
   ```typescript
   use_mcp_tool('memory-bank', 'update_context', {
     projectPath: '/path/to/project',
     content: {
       currentSession: {
         date: '2025-03-13',
         mode: 'development',
         task: 'Implementing new feature'
       }
     }
   });
   ```

3. `record_decision`
   - Records technical decisions with rationale
   - Maintains history of architectural choices
   ```typescript
   use_mcp_tool('memory-bank', 'record_decision', {
     projectPath: '/path/to/project',
     decision: {
       title: 'Authentication System',
       description: 'Implementing JWT-based authentication',
       rationale: 'Better scalability and stateless operation',
       alternatives: [
         'Session-based auth',
         'OAuth only'
       ]
     }
   });
   ```

4. `track_progress`
   - Updates project progress and milestones
   - Manages task status and blockers
   ```typescript
   use_mcp_tool('memory-bank', 'track_progress', {
     projectPath: '/path/to/project',
     progress: {
       completed: ['Setup project', 'Initialize database'],
       inProgress: ['Implement auth', 'Create API routes'],
       blocked: ['Deploy to production']
     }
   });
   ```

### Resources

1. `memory://project/context`
   - Project overview and technical stack
   - Architecture principles and guidelines

2. `memory://active/context`
   - Current session state and tasks
   - Active considerations and notes

3. `memory://progress`
   - Project milestones and task tracking
   - Work status and blockers

4. `memory://decisions`
   - Technical decisions and rationale
   - Architecture choices and alternatives

### System Prompt Suggestion

Add to Cline system prompt or `.clinerules` file under settings.

```
Memory Bank Integration Rules:

CRITICAL: Before ANY task or response:
1. ALWAYS check active context (memory://active/context):
   - Current project state and mode
   - Ongoing tasks and their status
   - Recent decisions and updates
   - Open questions and concerns

2. ALWAYS review project context (memory://project/context):
   - Technical stack and dependencies
   - Project guidelines and standards
   - Architecture principles
   - Development workflow

3. ALWAYS consult decision log (memory://decisions) for:
   - Previous architectural choices
   - Established patterns
   - Technical rationales
   - Related decisions

4. ALWAYS check progress tracking (memory://progress):
   - Current phase and milestones
   - Completed work
   - In-progress tasks
   - Known blockers

After EVERY task:
1. Update active context with:
   - Task completion status
   - New information learned
   - Changes made

2. Record any technical decisions with:
   - Clear rationale
   - Considered alternatives
   - Impact assessment

3. Update progress tracking:
   - Mark completed items
   - Add new tasks identified
   - Note any blockers found

Key Guidelines:
- NEVER proceed without checking memory bank context
- ALWAYS maintain consistent project state
- Record ALL significant technical decisions
- Track progress in real-time
- Keep context updated with EVERY change
```
## File Structure

When initialized, the Memory Bank creates the following structure in your project:

```mermaid
graph LR
    Root[Project Root] --> Bank[memory-bank]
    Bank --> PC[projectContext.md]
    Bank --> AC[activeContext.md]
    Bank --> P[progress.md]
    Bank --> DL[decisionLog.md]
    PC --> Stack[Technical Stack]
    AC --> Tasks[Active Tasks]
    P --> Status[Project Status]
    DL --> History[Decision History]
```

### Initial File Contents

Upon initialization, each file is populated with structured content:

1. `activeContext.md`:
   - Current session information with timestamp
   - Initial tasks (Project initialization, Environment setup)
   - Open questions about project goals and requirements
   - Recent updates section

2. `progress.md`:
   - Current phase (Initialization)
   - Initial completed tasks (Repository setup, Basic structure)
   - In-progress tasks (Environment configuration, Documentation)
   - Upcoming tasks section
   - Blockers tracking

3. `decisionLog.md`:
   - Initial project structure decisions
   - Development workflow choices with alternatives
   - Documentation strategy decisions
   - Section for pending decisions

4. `projectContext.md`:
   - Project overview and version
   - Detected technical stack and dependencies
   - Configuration files listing
   - Architecture principles
   - Development setup instructions
   - Project workflow guidelines

## Using with Cline

```mermaid
graph LR
    Start[Start] --> Init[Initialize]
    Init --> Context[Load Context]
    Context --> Update[Make Changes]
    Update --> Progress[Track Progress]
    Progress --> Record[Record Decisions]
    Record --> Sync[Auto Sync]
    Sync --> Context
```

Simply ask Cline to initialize the memory bank.  

1. Initialize a new Memory Bank:
   ```
   use_mcp_tool('memory-bank', 'initialize_memory_bank', {
     projectPath: process.cwd()  // or specific path
   });
   ```

2. Access project context:
   ```
   access_mcp_resource('memory-bank', 'memory://project/context');
   ```

3. Update session context:
   ```
   use_mcp_tool('memory-bank', 'update_context', {
     projectPath: process.cwd(),
     content: {
       currentSession: {
         date: new Date().toISOString().split('T')[0],
         mode: 'development',
         task: 'Current task description'
       }
     }
   });
   ```

4. Record technical decisions:
   ```
   use_mcp_tool('memory-bank', 'record_decision', {
     projectPath: process.cwd(),
     decision: {
       title: 'Decision Title',
       description: 'What was decided',
       rationale: 'Why it was decided'
     }
   });
   ```

## Development

To modify or enhance the server:

1. Update source in `src/index.ts`
2. Run tests: `npm test`
3. Build: `npm run build`
4. Restart Cline extension to load changes

## Contributing

Contributions are welcome! Please:

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Submit a pull request

## License

MIT  dazeb

================
File: memory-bank/memory-bank/src/index.ts
================
#!/usr/bin/env node
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ErrorCode,
  ListResourcesRequestSchema,
  ListToolsRequestSchema,
  McpError,
  ReadResourceRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import fs from 'fs/promises';
import os from 'os';
import path from 'path';

interface MemoryBankFile {
  path: string;
  content: string;
}

interface ProjectInfo {
  name: string;
  version: string;
  description: string;
  license: string;
  dependencies: string[];
  devDependencies: string[];
}

interface Decision {
  title: string;
  description: string;
  rationale: string;
  alternatives?: string[];
  date?: string;
  status: 'proposed' | 'accepted' | 'rejected' | 'superseded';
  impact?: string;
  relatedDecisions?: string[];
}

interface TechStack {
  runtime: string;
  frameworks: string[];
  languages: Set<string>;
  configs: string[];
}

interface SessionState {
  questionCount: number;
  lastPrompted: string;
  currentPhase: string;
  taskUpdates: {
    completed: Set<string>;
    inProgress: Set<string>;
    blocked: Set<string>;
  };
}

interface McpSettings {
  mcpServers: {
    [key: string]: {
      command: string;
      args: string[];
      env?: { [key: string]: string };
      disabled?: boolean;
      autoApprove?: string[];
    };
  };
}

class MemoryBankServer {
  private sessionState: SessionState;
  private server: Server;
  private memoryBankPath: string;
  private static readonly MCP_SETTINGS_PATHS = {
    linux: '.config/Code - Insiders/User/globalStorage/saoudrizwan.claude-dev/settings/cline_mcp_settings.json',
    darwin: 'Library/Application Support/Code - Insiders/User/globalStorage/saoudrizwan.claude-dev/settings/cline_mcp_settings.json',
    win32: 'AppData/Roaming/Code - Insiders/User/globalStorage/saoudrizwan.claude-dev/settings/cline_mcp_settings.json'
  };

  constructor() {
    this.sessionState = {
      questionCount: 0,
      lastPrompted: new Date().toISOString().split('T')[0],
      currentPhase: 'Development',
      taskUpdates: {
        completed: new Set<string>(),
        inProgress: new Set<string>(),
        blocked: new Set<string>()
      }
    };

    this.server = new Server(
      {
        name: 'memory-bank-server',
        version: '0.1.0',
      },
      {
        capabilities: {
          resources: {},
          tools: {},
        },
      }
    );

    this.memoryBankPath = 'memory-bank';
    this.setupToolHandlers();
    this.setupResourceHandlers();

    // Error handling
    this.server.onerror = (error: unknown) => {
      if (error instanceof Error) {
        console.error('[MCP Error]', error.message, error.stack);
      } else {
        console.error('[MCP Error]', error);
      }
    };
    process.on('SIGINT', async () => {
      await this.server.close();
      process.exit(0);
    });
  }

  private setupToolHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: 'initialize_memory_bank',
          description: 'Initialize Memory Bank structure for a project',
          inputSchema: {
            type: 'object',
            properties: {
              projectPath: {
                type: 'string',
                description: 'Path to project root directory',
              },
            },
            required: ['projectPath'],
          },
        },
        {
          name: 'update_context',
          description: 'Update active context with current session information',
          inputSchema: {
            type: 'object',
            properties: {
              projectPath: {
                type: 'string',
                description: 'Path to project root directory',
              },
              content: {
                type: 'object',
                description: 'Current session context to update',
                properties: {
                  currentSession: {
                    type: 'object',
                    properties: {
                      date: { type: 'string' },
                      mode: { type: 'string' },
                      task: { type: 'string' },
                    },
                    required: ['date', 'mode', 'task'],
                  },
                },
                required: ['currentSession'],
              },
            },
            required: ['projectPath', 'content'],
          },
        },
        {
          name: 'record_decision',
          description: 'Add a new technical decision with rationale and metadata',
          inputSchema: {
            type: 'object',
            properties: {
              projectPath: {
                type: 'string',
                description: 'Path to project root directory',
              },
              decision: {
                type: 'object',
                properties: {
                  title: { type: 'string', description: 'Title of the decision' },
                  description: { type: 'string', description: 'What was decided' },
                  rationale: { type: 'string', description: 'Why this decision was made' },
                  status: { 
                    type: 'string',
                    description: 'Current status of the decision',
                    enum: ['proposed', 'accepted', 'rejected', 'superseded'],
                    default: 'accepted'
                  },
                  impact: { 
                    type: 'string',
                    description: 'Areas of the project affected by this decision'
                  },
                  alternatives: { 
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Alternative options that were considered'
                  },
                  relatedDecisions: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Titles of related decisions'
                  },
                  date: {
                    type: 'string',
                    description: 'Optional decision date (defaults to current date)',
                    pattern: '^\\d{4}-\\d{2}-\\d{2}$'
                  }
                },
                required: ['title', 'description', 'rationale', 'status'],
              },
            },
            required: ['projectPath', 'decision'],
          },
        },
        {
          name: 'track_progress',
          description: 'Update project progress and milestones',
          inputSchema: {
            type: 'object',
            properties: {
              projectPath: {
                type: 'string',
                description: 'Path to project root directory',
              },
              progress: {
                type: 'object',
                properties: {
                  completed: { type: 'array', items: { type: 'string' } },
                  inProgress: { type: 'array', items: { type: 'string' } },
                  blocked: { type: 'array', items: { type: 'string' } },
                },
                required: ['completed', 'inProgress'],
              },
            },
            required: ['projectPath', 'progress'],
          },
        },
      ],
    }));

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      try {
        switch (request.params.name) {
          case 'initialize_memory_bank':
            return await this.handleInitializeMemoryBank(request.params.arguments);
          case 'update_context':
            return await this.handleUpdateContext(request.params.arguments);
          case 'record_decision':
            return await this.handleRecordDecision(request.params.arguments);
          case 'track_progress':
            return await this.handleTrackProgress(request.params.arguments);
          default:
            throw new McpError(
              ErrorCode.MethodNotFound,
              `Unknown tool: ${request.params.name}`
            );
        }
      } catch (error: unknown) {
        if (error instanceof McpError) throw error;
        throw new McpError(
          ErrorCode.InternalError,
          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }

  private setupResourceHandlers() {
    this.server.setRequestHandler(ListResourcesRequestSchema, async () => ({
      resources: [
        {
          uri: 'memory://project/context',
          name: 'Project Context',
          description: 'Project overview, technical stack, and guidelines',
          mimeType: 'text/markdown',
        },
        {
          uri: 'memory://active/context',
          name: 'Active Context',
          description: 'Current session state and tasks',
          mimeType: 'text/markdown',
        },
        {
          uri: 'memory://progress',
          name: 'Progress Log',
          description: 'Project milestones and task tracking',
          mimeType: 'text/markdown',
        },
        {
          uri: 'memory://decisions',
          name: 'Decision Log',
          description: 'Technical decisions and rationale',
          mimeType: 'text/markdown',
        },
      ],
    }));

    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
      const projectPath = process.env.PROJECT_PATH;
      if (!projectPath) {
        throw new McpError(
          ErrorCode.InvalidRequest,
          'PROJECT_PATH environment variable not set'
        );
      }

      try {
        const content = await this.readMemoryBankFile(
          projectPath,
          this.getFileNameFromUri(request.params.uri)
        );

        return {
          contents: [
            {
              uri: request.params.uri,
              mimeType: 'text/markdown',
              text: content,
            },
          ],
        };
      } catch (error: unknown) {
        throw new McpError(
          ErrorCode.InternalError,
          `Failed to read resource: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }

  private async getProjectInfo(projectPath: string): Promise<ProjectInfo> {
    try {
      const packageJsonPath = path.join(projectPath, 'package.json');
      const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
      
      return {
        name: packageJson.name || 'Unknown',
        version: packageJson.version || '0.1.0',
        description: packageJson.description || 'No description provided',
        license: packageJson.license || 'Not specified',
        dependencies: Object.keys(packageJson.dependencies || {}),
        devDependencies: Object.keys(packageJson.devDependencies || {})
      };
    } catch (error) {
      return {
        name: 'Unknown',
        version: '0.1.0',
        description: 'No description provided',
        license: 'Not specified',
        dependencies: [],
        devDependencies: []
      };
    }
  }

  private async detectTechStack(projectPath: string): Promise<TechStack> {
    const stack: TechStack = {
      runtime: 'Node.js',
      frameworks: [],
      languages: new Set<string>(),
      configs: []
    };

    // Define valid programming language extensions
    const validLanguages = new Map([
      ['js', 'JavaScript'],
      ['mjs', 'JavaScript'],
      ['jsx', 'JavaScript (React)'],
      ['ts', 'TypeScript'],
      ['tsx', 'TypeScript (React)'],
      ['py', 'Python'],
      ['rb', 'Ruby'],
      ['php', 'PHP'],
      ['java', 'Java'],
      ['go', 'Go'],
      ['rs', 'Rust'],
      ['c', 'C'],
      ['cpp', 'C++'],
      ['h', 'C/C++ Header'],
      ['cs', 'C#'],
      ['swift', 'Swift'],
      ['kt', 'Kotlin'],
      ['dart', 'Dart']
    ]);

    // Define relevant config files
    const relevantConfigs = new Set([
      'package.json',
      'tsconfig.json',
      '.eslintrc',
      '.prettierrc',
      '.babelrc',
      '.env',
      'webpack.config.js',
      'vite.config.js',
      'next.config.js',
      '.gitignore',
      'jest.config.js',
      'rollup.config.js'
    ]);

    try {
      const files = await fs.readdir(projectPath, { recursive: true });
      
      // Process each file
      files.forEach((file: string) => {
        const ext = path.extname(file).toLowerCase().substring(1);
        const basename = path.basename(file);
        
        // Add valid programming languages
        if (validLanguages.has(ext)) {
          stack.languages.add(validLanguages.get(ext)!);
        }
        
        // Add relevant config files
        if (relevantConfigs.has(basename)) {
          stack.configs.push(basename);
        }
      });

      // Remove duplicates from configs
      stack.configs = [...new Set(stack.configs)];

      // Detect frameworks from package.json
      const packageJson = await fs.readFile(path.join(projectPath, 'package.json'), 'utf8');
      const { dependencies = {}, devDependencies = {} } = JSON.parse(packageJson);
      
      const allDeps = { ...dependencies, ...devDependencies };
      const frameworkDetection = {
        'react': 'React',
        'next': 'Next.js',
        'express': 'Express',
        'vue': 'Vue.js',
        'angular': 'Angular',
        'svelte': 'Svelte',
        'nestjs': 'NestJS',
        '@nestjs/core': 'NestJS',
        'fastify': 'Fastify',
        'koa': 'Koa',
        'gatsby': 'Gatsby',
        'nuxt': 'Nuxt.js'
      };

      for (const [dep, framework] of Object.entries(frameworkDetection)) {
        if (allDeps[dep]) {
          stack.frameworks.push(framework);
        }
      }

      return stack;
    } catch (error) {
      return stack;
    }
  }

  private generateInitialDecisions(info: ProjectInfo, stack: TechStack): Decision[] {
    const decisions: Decision[] = [
      {
        title: 'Initial Project Structure',
        description: `Initialized ${info.name} with a modular architecture using ${stack.runtime}`,
        rationale: 'Established foundation for scalable and maintainable development',
        status: 'accepted',
        impact: 'Project-wide',
        date: new Date().toISOString().split('T')[0]
      }
    ];

    // Add framework-specific decisions
    if (stack.frameworks.length > 0) {
      decisions.push({
        title: 'Framework Selection',
        description: `Selected ${stack.frameworks.join(', ')} as primary framework(s)`,
        rationale: 'Chosen based on project requirements and team expertise',
        status: 'accepted',
        impact: 'Technical architecture',
        date: new Date().toISOString().split('T')[0]
      });
    }

    return decisions;
  }

  private formatDecisionLog(decisions: Decision[]): string {
    return `# Decision Log

## Technical Decisions

${decisions.map(d => `### ${d.title} (${d.date || 'No date'})
${d.description}

**Status:** ${d.status}
${d.impact ? `**Impact:** ${d.impact}\n` : ''}
Rationale:
${d.rationale}

${d.alternatives ? `Alternatives Considered:\n${d.alternatives.map(alt => `- ${alt}`).join('\n')}\n` : ''}
${d.relatedDecisions ? `Related Decisions:\n${d.relatedDecisions.map(rd => `- ${rd}`).join('\n')}` : ''}`).join('\n\n')}

## Pending Decisions
`;
  }

  private formatProjectContext(info: ProjectInfo, stack: TechStack): string {
    // Filter out core dependencies
    const corePackages = new Set(['@types/node', 'typescript', 'ts-node', 'nodemon']);
    const keyDeps = info.dependencies.filter(d => !corePackages.has(d));
    const keyDevDeps = info.devDependencies.filter(d => !corePackages.has(d));

    const formatDeps = (deps: string[]) => 
      deps.length ? deps.map(d => `- ${d}`).join('\n') : 'None';

    return `# Project Context

## Overview
${info.name} - ${info.description}
Version: ${info.version}
License: ${info.license}

## Technical Stack
Runtime: ${stack.runtime}
${stack.languages.size ? `Languages: ${Array.from(stack.languages).sort().join(', ')}` : ''}
${stack.frameworks.length ? `Frameworks: ${stack.frameworks.join(', ')}` : ''}

## Dependencies
Core:
${formatDeps(keyDeps)}

Development:
${formatDeps(keyDevDeps)}

## Configuration
${stack.configs.sort().map(c => `- ${c}`).join('\n')}

## Architecture
- Type: ${stack.frameworks.length ? `Framework-based (${stack.frameworks.join(', ')})` : 'Modular'}
- Language: ${Array.from(stack.languages)[0] || 'Not detected'}
- Environment: Node.js
${info.dependencies.includes('@modelcontextprotocol/sdk') ? '- MCP Server Implementation' : ''}
`;
  }

  public async handleInitializeMemoryBank(args: any) {
    const projectPath = args.projectPath;
    if (!projectPath) {
      throw new McpError(ErrorCode.InvalidParams, 'Project path is required');
    }

    // Convert to absolute path if not already
    const absoluteProjectPath = path.isAbsolute(projectPath) 
      ? projectPath 
      : path.resolve(process.cwd(), projectPath);

    try {
      const memoryBankPath = path.join(projectPath, this.memoryBankPath);
      await fs.mkdir(memoryBankPath, { recursive: true });

      // Gather project information
      const projectInfo = await this.getProjectInfo(projectPath);
      const techStack = await this.detectTechStack(projectPath);
      const projectContext = this.formatProjectContext(projectInfo, techStack);

      // Generate initial decisions
      const initialDecisions = this.generateInitialDecisions(projectInfo, techStack);
      
      const currentDate = new Date().toISOString().split('T')[0];
      const currentTime = new Date().toLocaleTimeString();
      
      const files: MemoryBankFile[] = [
        {
          path: 'projectContext.md',
          content: projectContext,
        },
        {
          path: 'activeContext.md',
          content: `# Active Context

## Current Session
Started: ${currentDate} ${currentTime}
Mode: Development
Current Task: Initial Setup

## Tasks
### In Progress
- [ ] Project initialization
- [ ] Environment setup

## Open Questions
- What are the primary project goals?
- What are the key technical requirements?

## Recent Updates
- ${currentDate}: Project initialized`,
        },
        {
          path: 'progress.md',
          content: `# Progress Log

## Current Phase
Initialization

## Completed Tasks
- Repository setup (${currentDate})
- Basic project structure (${currentDate})

## In Progress
- Development environment configuration
- Initial documentation

## Upcoming
- Code implementation
- Testing setup

## Blockers
[None currently identified]`,
        },
        {
          path: 'decisionLog.md',
          content: this.formatDecisionLog([
            ...initialDecisions,
            {
              title: 'Development Workflow',
              description: 'Established initial development workflow and practices',
              rationale: 'Ensure consistent development process and code quality',
              status: 'accepted',
              impact: 'Development process',
              date: currentDate,
              alternatives: [
                'Ad-hoc development process',
                'Waterfall methodology'
              ]
            },
            {
              title: 'Documentation Strategy',
              description: 'Implemented automated documentation with memory bank',
              rationale: 'Maintain up-to-date project context and decision history',
              status: 'accepted',
              impact: 'Project documentation',
              date: currentDate
            }
          ]),
        },
      ];

      for (const file of files) {
        await fs.writeFile(
          path.join(memoryBankPath, file.path),
          file.content,
          'utf8'
        );
      }

      // Update MCP settings
      await this.updateMcpSettings(absoluteProjectPath);

      return {
        content: [
          {
            type: 'text',
            text: 'Memory Bank initialized successfully and MCP settings configured',
          },
        ],
      };
    } catch (error: unknown) {
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to initialize Memory Bank: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  private async handleUpdateContext(args: any) {
    const { projectPath, content } = args;
    if (!projectPath || !content) {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Project path and content are required'
      );
    }

    try {
      const filePath = path.join(projectPath, this.memoryBankPath, 'activeContext.md');
      const currentContent = await fs.readFile(filePath, 'utf8');
      const updatedContent = this.mergeContext(currentContent, content);
      await fs.writeFile(filePath, updatedContent, 'utf8');

      return {
        content: [
          {
            type: 'text',
            text: 'Active context updated successfully',
          },
        ],
      };
    } catch (error: unknown) {
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to update context: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  private async handleRecordDecision(args: any) {
    const { projectPath, decision } = args;
    if (!projectPath || !decision) {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Project path and decision are required'
      );
    }

    try {
      const filePath = path.join(projectPath, this.memoryBankPath, 'decisionLog.md');
      const currentContent = await fs.readFile(filePath, 'utf8');
      const updatedContent = this.addDecision(currentContent, decision);
      await fs.writeFile(filePath, updatedContent, 'utf8');

      return {
        content: [
          {
            type: 'text',
            text: 'Decision recorded successfully',
          },
        ],
      };
    } catch (error: unknown) {
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to record decision: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  private async handleTrackProgress(args: any) {
    const { projectPath, progress } = args;
    if (!projectPath || !progress) {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Project path and progress are required'
      );
    }

    try {
      const filePath = path.join(projectPath, this.memoryBankPath, 'progress.md');
      const currentContent = await fs.readFile(filePath, 'utf8');
      const updatedContent = this.updateProgress(currentContent, progress);
      await fs.writeFile(filePath, updatedContent, 'utf8');

      return {
        content: [
          {
            type: 'text',
            text: 'Progress updated successfully',
          },
        ],
      };
    } catch (error: unknown) {
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to update progress: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  private async updateMcpSettings(projectPath: string): Promise<void> {
    try {
      const settingsPath = await this.getMcpSettingsPath();
      const settings = await this.readMcpSettings(settingsPath);
      
      // Update memory-bank server configuration
      settings.mcpServers = settings.mcpServers || {};
      settings.mcpServers['memory-bank'] = {
        command: 'node',
        args: [path.join(projectPath, 'build', 'index.js')],
        env: {
          PROJECT_PATH: projectPath
        },
        disabled: false,
        autoApprove: []
      };

      await this.writeMcpSettings(settingsPath, settings);
    } catch (error: unknown) {
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to update MCP settings: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  private async getMcpSettingsPath(): Promise<string> {
    let homedir: string;
    try {
      homedir = os.homedir();
    } catch (error) {
      console.error('Error getting home directory:', error);
      throw new Error(`Could not determine user home directory: ${error instanceof Error ? error.message : String(error)}`);
    }

    const platform = process.platform as keyof typeof MemoryBankServer.MCP_SETTINGS_PATHS;
    const relativePath = MemoryBankServer.MCP_SETTINGS_PATHS[platform];
    if (!relativePath) {
      throw new Error(`Unsupported platform: ${platform}`);
    }

    return path.join(homedir, relativePath);
  }

  private async readMcpSettings(settingsPath: string): Promise<McpSettings> {
    try {
      const content = await fs.readFile(settingsPath, 'utf8');
      return JSON.parse(content);
    } catch (error) {
      if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {
        // Return default settings if file doesn't exist
        return { mcpServers: {} };
      }
      throw error;
    }
  }

  private async writeMcpSettings(settingsPath: string, settings: McpSettings): Promise<void> {
    // Ensure settings directory exists
    await fs.mkdir(path.dirname(settingsPath), { recursive: true });
    await fs.writeFile(settingsPath, JSON.stringify(settings, null, 2), 'utf8');
  }

  private async readMemoryBankFile(projectPath: string, fileName: string): Promise<string> {
    const filePath = path.join(projectPath, this.memoryBankPath, fileName);
    try {
      return await fs.readFile(filePath, 'utf8');
    } catch (error: unknown) {
      throw new Error(`Failed to read file ${fileName}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private getFileNameFromUri(uri: string): string {
    const mapping: { [key: string]: string } = {
      'memory://project/context': 'projectContext.md',
      'memory://active/context': 'activeContext.md',
      'memory://progress': 'progress.md',
      'memory://decisions': 'decisionLog.md',
    };

    const fileName = mapping[uri];
    if (!fileName) {
      throw new Error(`Invalid URI: ${uri}`);
    }

    return fileName;
  }

  private mergeContext(current: string, update: any): string {
    const date = new Date().toISOString().split('T')[0];
    return `${current}\n\n## Session Update (${date})\n- Mode: ${update.currentSession.mode}\n- Task: ${update.currentSession.task}`;
  }

  private addDecision(current: string, decision: Decision): string {
    const date = decision.date || new Date().toISOString().split('T')[0];
    const alternatives = decision.alternatives
      ? `\n\nAlternatives Considered:\n${decision.alternatives.map((alt: string) => `- ${alt}`).join('\n')}`
      : '';
    const impact = decision.impact ? `\n**Impact:** ${decision.impact}` : '';
    const related = decision.relatedDecisions
      ? `\n\nRelated Decisions:\n${decision.relatedDecisions.map((rd: string) => `- ${rd}`).join('\n')}`
      : '';

    // Find the appropriate section based on status
    const statusSection = decision.status === 'proposed' ? '## Pending Decisions' : '## Technical Decisions';
    const sections = current.split('\n\n## ');
    const targetSectionIndex = sections.findIndex(s => s.startsWith('Technical Decisions') || s.startsWith('Pending Decisions'));
    
    if (targetSectionIndex === -1) return current; // Fallback if sections not found

    const newDecision = `### ${decision.title} (${date})
${decision.description}

**Status:** ${decision.status}${impact}

Rationale:
${decision.rationale}${alternatives}${related}`;

    sections[targetSectionIndex] = sections[targetSectionIndex].trim() + '\n\n' + newDecision;
    return sections.join('\n\n## ');
  }

  private async checkAndPromptProgress(): Promise<void> {
    if (this.sessionState.questionCount >= 10) {
      this.sessionState.questionCount = 0; // Reset counter
      this.sessionState.lastPrompted = new Date().toISOString().split('T')[0];
      
      // Auto-save progress
      await this.saveProgressUpdate();
    }
  }

  private async saveProgressUpdate(): Promise<void> {
    const projectPath = process.env.PROJECT_PATH;
    if (!projectPath) return;

    const progress = {
      completed: Array.from(this.sessionState.taskUpdates.completed),
      inProgress: Array.from(this.sessionState.taskUpdates.inProgress),
      blocked: Array.from(this.sessionState.taskUpdates.blocked)
    };

    await this.handleTrackProgress({
      projectPath,
      progress
    });

    // Clear the sets after saving
    this.sessionState.taskUpdates.completed.clear();
    this.sessionState.taskUpdates.inProgress.clear();
    this.sessionState.taskUpdates.blocked.clear();
  }

  private updateProgress(current: string, progress: any): string {
    const date = new Date().toISOString().split('T')[0];
    
    // Add tasks to session state
    progress.completed?.forEach((task: string) => this.sessionState.taskUpdates.completed.add(task));
    progress.inProgress?.forEach((task: string) => this.sessionState.taskUpdates.inProgress.add(task));
    progress.blocked?.forEach((task: string) => this.sessionState.taskUpdates.blocked.add(task));

    const completed = progress.completed.map((task: string) => `-  ${task}`).join('\n');
    const inProgress = progress.inProgress.map((task: string) => `-  ${task}`).join('\n');
    const blocked = progress.blocked
      ? `\n\nBlocked:\n${progress.blocked.map((task: string) => `-  ${task}`).join('\n')}`
      : '';

    this.sessionState.questionCount++; // Increment question counter
    this.checkAndPromptProgress(); // Check if we should prompt for progress save

    return `${current}\n\n## Update (${date})\nPhase: ${this.sessionState.currentPhase}\nQuestions Processed: ${this.sessionState.questionCount}\n\nCompleted:\n${completed}\n\nIn Progress:\n${inProgress}${blocked}`;
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    
    // Initialize with current phase
    this.sessionState.currentPhase = 'Development';
    console.error('Memory Bank MCP server running on stdio');
  }
}

async function handleCliCommand() {
  if (process.argv[2] === 'initialize_memory_bank') {
    const projectPath = process.argv[3];
    if (!projectPath) {
      console.error('Error: Project path is required');
      process.exit(1);
    }

    const server = new MemoryBankServer();
    try {
      const result = await server.handleInitializeMemoryBank({ projectPath });
      console.log(result.content[0].text);
      process.exit(0);
    } catch (error) {
      console.error('Error:', error instanceof Error ? error.message : String(error));
      process.exit(1);
    }
  } else {
    // Run as MCP server
    const server = new MemoryBankServer();
    server.run().catch(console.error);
  }
}

handleCliCommand();

================
File: memory-bank/memory-bank/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./build",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

================
File: .github/workflows/dev-deploy.yml
================
name: Development Deployment

on:
  push:
    branches: [ develop ]
  workflow_dispatch:

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install Backend Dependencies
        run: |
          cd backend
          npm ci
          
      - name: Run Backend Tests
        run: |
          cd backend
          npm test
          
      - name: Install Frontend Dependencies
        run: |
          cd frontend
          npm ci
          
      - name: Run Frontend Tests
        run: |
          cd frontend
          npm test
        
  deploy:
    name: Deploy to Development
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.DEV_SSH_PRIVATE_KEY }}
          
      - name: Deploy to Development Server
        run: |
          # Add server to known hosts
          ssh-keyscan -H ${{ secrets.DEV_SERVER_IP }} >> ~/.ssh/known_hosts
          
          # Deploy to server
          ssh ${{ secrets.DEV_SERVER_USER }}@${{ secrets.DEV_SERVER_IP }} "cd ${{ secrets.DEV_PROJECT_PATH }} && \
          git pull && \
          docker-compose -f docker-compose.dev.yml down && \
          docker-compose -f docker-compose.dev.yml build && \
          docker-compose -f docker-compose.dev.yml up -d"

================
File: .github/workflows/prod-deploy.yml
================
name: Production Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install Backend Dependencies
        run: |
          cd backend
          npm ci
          
      - name: Run Backend Tests
        run: |
          cd backend
          npm test
          
      - name: Install Frontend Dependencies
        run: |
          cd frontend
          npm ci
          
      - name: Run Frontend Tests
        run: |
          cd frontend
          npm test
  
  approve:
    name: Manual Approval
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Manual Approval for Production Deployment
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          approvers: amitaik
          minimum-approvals: 1
          issue-title: "Deploying to Production"
          issue-body: "Please approve the deployment to production"
          exclude-workflow-initiator-as-approver: false
      
  deploy:
    name: Deploy to Production
    needs: approve
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.PROD_SSH_PRIVATE_KEY }}
          
      - name: Create Tag
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          VERSION=$(date '+%Y.%m.%d.%H%M')
          git tag -a "v$VERSION" -m "Production release v$VERSION"
          git push origin "v$VERSION"
          
      - name: Deploy to Production Server
        run: |
          # Add server to known hosts
          ssh-keyscan -H ${{ secrets.PROD_SERVER_IP }} >> ~/.ssh/known_hosts
          
          # Backup database before deployment
          ssh ${{ secrets.PROD_SERVER_USER }}@${{ secrets.PROD_SERVER_IP }} \
            "cd ${{ secrets.PROD_PROJECT_PATH }} && \
             docker-compose -f docker-compose.prod.yml exec -T db pg_dump -U postgres -d ala_db > backup_\$(date +%Y%m%d_%H%M%S).sql"
          
          # Deploy to server
          ssh ${{ secrets.PROD_SERVER_USER }}@${{ secrets.PROD_SERVER_IP }} \
            "cd ${{ secrets.PROD_PROJECT_PATH }} && \
             git fetch --all && \
             git checkout main && \
             git pull && \
             docker-compose -f docker-compose.prod.yml down && \
             docker-compose -f docker-compose.prod.yml build && \
             docker-compose -f docker-compose.prod.yml up -d"

================
File: .gitignore
================
# Node
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build output
dist/
build/

# Vite
.vite/

# Logs
logs/
*.log

# dotenv environment variables
.env*

# Docker
*.pid
docker-compose.override.yml

# OS
.DS_Store
Thumbs.db

# IDE
.vscode/
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln

================
File: ala-dev.bat
================
@echo off
setlocal enabledelayedexpansion

echo =====================================================
echo    Accountability Log Application (ALA) Dev Tools
echo =====================================================
echo.

:menu
cls
echo Choose an option:
echo.
echo [1] Start Development Environment
echo [2] Stop Development Environment
echo [3] Restart Development Environment
echo [4] View Logs
echo [5] Run Diagnostics
echo [6] Open Application in Browser
echo [0] Exit
echo.
set /p choice="Enter your choice (0-6): "

if "%choice%"=="1" goto start
if "%choice%"=="2" goto stop
if "%choice%"=="3" goto restart
if "%choice%"=="4" goto logs
if "%choice%"=="5" goto diagnostics
if "%choice%"=="6" goto openapp
if "%choice%"=="0" goto end

echo Invalid choice! Please try again.
timeout /t 2 >nul
goto menu

:start
echo.
echo Starting development environment...
echo.
docker-compose -f docker-compose.dev.yml up -d --build
echo.
echo Development environment started!
echo.
echo Frontend: http://localhost:3000
echo Backend API: http://localhost:5000
echo.
pause
goto menu

:stop
echo.
echo Stopping development environment...
echo.
docker-compose -f docker-compose.dev.yml down
echo.
echo Development environment stopped.
echo.
pause
goto menu

:restart
echo.
echo Restarting development environment...
echo.
docker-compose -f docker-compose.dev.yml down
docker-compose -f docker-compose.dev.yml up -d
echo.
echo Development environment restarted!
echo.
pause
goto menu

:logs
echo.
echo Viewing logs (press Ctrl+C to return to menu)...
echo.
docker-compose -f docker-compose.dev.yml logs -f
goto menu

:diagnostics
echo.
echo Running system diagnostics...
echo.

:: Check if Node.js is installed
node --version >nul 2>&1
if !ERRORLEVEL! NEQ 0 (
  echo ERROR: Node.js is not installed or not in PATH
  echo Please install Node.js and try again
) else (
  echo Node.js is installed and in PATH
)

:: Check if Docker is installed
docker --version >nul 2>&1
if !ERRORLEVEL! NEQ 0 (
  echo ERROR: Docker is not installed or not in PATH
  echo Please install Docker Desktop and try again
) else (
  echo Docker is installed and in PATH
)

:: Check if Docker Compose is installed
docker-compose --version >nul 2>&1
if !ERRORLEVEL! NEQ 0 (
  echo ERROR: Docker Compose is not installed or not in PATH
  echo Please ensure Docker Compose is installed with Docker Desktop
) else (
  echo Docker Compose is installed and in PATH
)

:: Check if containers are running
echo.
echo Current container status:
docker-compose -f docker-compose.dev.yml ps

:: Check backend health
echo.
echo Checking backend API health...
curl -s http://localhost:5000/api/health || echo Backend API is not responding

echo.
echo Diagnostics complete!
echo.
pause
goto menu

:openapp
echo.
echo Opening application in browser...
start "" http://localhost:3000
goto menu

:end
echo.
echo Exiting ALA Dev Tools...
echo.
endlocal
exit /b

================
File: azure/azure-deploy.sh
================
#!/bin/bash

# Configuration Variables
RESOURCE_GROUP="ala-resource-group"
LOCATION="westeurope"
ACR_NAME="alaregistry"
APP_NAME="accountability-log-app"
DATABASE_NAME="ala-db"
DATABASE_SKU="Basic"
DATABASE_USERNAME="postgres"
DATABASE_PASSWORD="P@ssw0rd123!"  # Change this for production!

# Set the current subscription (uncomment and set if needed)
# az account set --subscription "YOUR_SUBSCRIPTION_ID"

# Create Resource Group
echo "Creating Resource Group..."
az group create --name $RESOURCE_GROUP --location $LOCATION

# Create Azure Container Registry
echo "Creating Azure Container Registry..."
az acr create --resource-group $RESOURCE_GROUP --name $ACR_NAME --sku Basic --admin-enabled true

# Get ACR credentials
ACR_USERNAME=$(az acr credential show --name $ACR_NAME --query "username" -o tsv)
ACR_PASSWORD=$(az acr credential show --name $ACR_NAME --query "passwords[0].value" -o tsv)

# Log in to ACR
echo "Logging in to ACR..."
az acr login --name $ACR_NAME

# Build and push backend image
echo "Building and pushing backend image..."
cd ../backend
az acr build --registry $ACR_NAME --image ala-backend:latest .

# Build and push frontend image
echo "Building and pushing frontend image..."
cd ../frontend
az acr build --registry $ACR_NAME --image ala-frontend:latest .

# Create Azure Database for PostgreSQL
echo "Creating PostgreSQL database..."
az postgres flexible-server create \
  --resource-group $RESOURCE_GROUP \
  --name $DATABASE_NAME \
  --location $LOCATION \
  --admin-user $DATABASE_USERNAME \
  --admin-password $DATABASE_PASSWORD \
  --sku-name $DATABASE_SKU \
  --version 15 \
  --yes

# Create database
echo "Creating application database..."
az postgres flexible-server db create \
  --resource-group $RESOURCE_GROUP \
  --server-name $DATABASE_NAME \
  --database-name ala_db

# Allow Azure services
echo "Configuring firewall rules..."
az postgres flexible-server firewall-rule create \
  --resource-group $RESOURCE_GROUP \
  --name $DATABASE_NAME \
  --rule-name AllowAzureServices \
  --start-ip-address 0.0.0.0 \
  --end-ip-address 0.0.0.0

# Create App Service Plan
echo "Creating App Service Plan..."
az appservice plan create \
  --resource-group $RESOURCE_GROUP \
  --name ala-service-plan \
  --is-linux \
  --sku B1

# Create Web App for Backend
echo "Creating Web App for Backend..."
az webapp create \
  --resource-group $RESOURCE_GROUP \
  --plan ala-service-plan \
  --name $APP_NAME-api \
  --deployment-container-image-name $ACR_NAME.azurecr.io/ala-backend:latest

# Create Web App for Frontend
echo "Creating Web App for Frontend..."
az webapp create \
  --resource-group $RESOURCE_GROUP \
  --plan ala-service-plan \
  --name $APP_NAME \
  --deployment-container-image-name $ACR_NAME.azurecr.io/ala-frontend:latest

# Configure Backend Environment Variables
echo "Configuring Backend Environment Variables..."
az webapp config appsettings set \
  --resource-group $RESOURCE_GROUP \
  --name $APP_NAME-api \
  --settings \
  NODE_ENV=production \
  PORT=80 \
  DATABASE_URL="postgres://$DATABASE_USERNAME:$DATABASE_PASSWORD@$DATABASE_NAME.postgres.database.azure.com:5432/ala_db?sslmode=require" \
  JWT_SECRET="your-jwt-secret-key-change-in-production" \
  PRIORITY_URL="https://t.eu.priority-connect.online/odata/Priority/tabbtbc6.ini/test24/"

# Configure Frontend Environment Variables
echo "Configuring Frontend Environment Variables..."
az webapp config appsettings set \
  --resource-group $RESOURCE_GROUP \
  --name $APP_NAME \
  --settings \
  API_URL="https://$APP_NAME-api.azurewebsites.net"

# Configure Container Registry Settings in Web Apps
echo "Configuring Container Registry Settings..."
az webapp config container set \
  --resource-group $RESOURCE_GROUP \
  --name $APP_NAME-api \
  --docker-custom-image-name $ACR_NAME.azurecr.io/ala-backend:latest \
  --docker-registry-server-url https://$ACR_NAME.azurecr.io \
  --docker-registry-server-user $ACR_USERNAME \
  --docker-registry-server-password $ACR_PASSWORD

az webapp config container set \
  --resource-group $RESOURCE_GROUP \
  --name $APP_NAME \
  --docker-custom-image-name $ACR_NAME.azurecr.io/ala-frontend:latest \
  --docker-registry-server-url https://$ACR_NAME.azurecr.io \
  --docker-registry-server-user $ACR_USERNAME \
  --docker-registry-server-password $ACR_PASSWORD

echo "Deployment completed!"
echo "Frontend URL: https://$APP_NAME.azurewebsites.net"
echo "Backend API URL: https://$APP_NAME-api.azurewebsites.net"

================
File: azure/deploy.ps1
================
# Configuration Variables
$RESOURCE_GROUP = "ala-resource-group"
$LOCATION = "westeurope"
$ACR_NAME = "alaregistry"
$APP_NAME = "accountability-log-app"
$DATABASE_NAME = "ala-db"
$DATABASE_SKU = "Basic"
$DATABASE_USERNAME = "postgres"
$DATABASE_PASSWORD = "P@ssw0rd123!"  # Change this for production!

# Set the current subscription (uncomment and set if needed)
# Select-AzSubscription -SubscriptionId "YOUR_SUBSCRIPTION_ID"

# Create Resource Group
Write-Host "Creating Resource Group..."
az group create --name $RESOURCE_GROUP --location $LOCATION

# Create Azure Container Registry
Write-Host "Creating Azure Container Registry..."
az acr create --resource-group $RESOURCE_GROUP --name $ACR_NAME --sku Basic --admin-enabled true

# Get ACR credentials
$ACR_USERNAME = az acr credential show --name $ACR_NAME --query "username" -o tsv
$ACR_PASSWORD = az acr credential show --name $ACR_NAME --query "passwords[0].value" -o tsv

# Log in to ACR
Write-Host "Logging in to ACR..."
az acr login --name $ACR_NAME

# Build and push backend image
Write-Host "Building and pushing backend image..."
Set-Location -Path ..\backend
az acr build --registry $ACR_NAME --image ala-backend:latest .

# Build and push frontend image
Write-Host "Building and pushing frontend image..."
Set-Location -Path ..\frontend
az acr build --registry $ACR_NAME --image ala-frontend:latest .

# Create Azure Database for PostgreSQL
Write-Host "Creating PostgreSQL database..."
az postgres flexible-server create `
  --resource-group $RESOURCE_GROUP `
  --name $DATABASE_NAME `
  --location $LOCATION `
  --admin-user $DATABASE_USERNAME `
  --admin-password $DATABASE_PASSWORD `
  --sku-name $DATABASE_SKU `
  --version 15 `
  --yes

# Create database
Write-Host "Creating application database..."
az postgres flexible-server db create `
  --resource-group $RESOURCE_GROUP `
  --server-name $DATABASE_NAME `
  --database-name ala_db

# Allow Azure services
Write-Host "Configuring firewall rules..."
az postgres flexible-server firewall-rule create `
  --resource-group $RESOURCE_GROUP `
  --name $DATABASE_NAME `
  --rule-name AllowAzureServices `
  --start-ip-address 0.0.0.0 `
  --end-ip-address 0.0.0.0

# Create App Service Plan
Write-Host "Creating App Service Plan..."
az appservice plan create `
  --resource-group $RESOURCE_GROUP `
  --name ala-service-plan `
  --is-linux `
  --sku B1

# Create Web App for Backend
Write-Host "Creating Web App for Backend..."
az webapp create `
  --resource-group $RESOURCE_GROUP `
  --plan ala-service-plan `
  --name "$APP_NAME-api" `
  --deployment-container-image-name "$ACR_NAME.azurecr.io/ala-backend:latest"

# Create Web App for Frontend
Write-Host "Creating Web App for Frontend..."
az webapp create `
  --resource-group $RESOURCE_GROUP `
  --plan ala-service-plan `
  --name $APP_NAME `
  --deployment-container-image-name "$ACR_NAME.azurecr.io/ala-frontend:latest"

# Configure Backend Environment Variables
Write-Host "Configuring Backend Environment Variables..."
az webapp config appsettings set `
  --resource-group $RESOURCE_GROUP `
  --name "$APP_NAME-api" `
  --settings `
  NODE_ENV=production `
  PORT=80 `
  DATABASE_URL="postgres://$DATABASE_USERNAME:$DATABASE_PASSWORD@$DATABASE_NAME.postgres.database.azure.com:5432/ala_db?sslmode=require" `
  JWT_SECRET="your-jwt-secret-key-change-in-production" `
  PRIORITY_URL="https://t.eu.priority-connect.online/odata/Priority/tabbtbc6.ini/test24/"

# Configure Frontend Environment Variables
Write-Host "Configuring Frontend Environment Variables..."
az webapp config appsettings set `
  --resource-group $RESOURCE_GROUP `
  --name $APP_NAME `
  --settings `
  API_URL="https://$APP_NAME-api.azurewebsites.net"

# Configure Container Registry Settings in Web Apps
Write-Host "Configuring Container Registry Settings..."
az webapp config container set `
  --resource-group $RESOURCE_GROUP `
  --name "$APP_NAME-api" `
  --docker-custom-image-name "$ACR_NAME.azurecr.io/ala-backend:latest" `
  --docker-registry-server-url "https://$ACR_NAME.azurecr.io" `
  --docker-registry-server-user $ACR_USERNAME `
  --docker-registry-server-password $ACR_PASSWORD

az webapp config container set `
  --resource-group $RESOURCE_GROUP `
  --name $APP_NAME `
  --docker-custom-image-name "$ACR_NAME.azurecr.io/ala-frontend:latest" `
  --docker-registry-server-url "https://$ACR_NAME.azurecr.io" `
  --docker-registry-server-user $ACR_USERNAME `
  --docker-registry-server-password $ACR_PASSWORD

Write-Host "Deployment completed!"
Write-Host "Frontend URL: https://$APP_NAME.azurewebsites.net"
Write-Host "Backend API URL: https://$APP_NAME-api.azurewebsites.net"

# Return to the original directory
Set-Location -Path ..\..\azure

================
File: azure/README.md
================
#   Accountability Log Application  Azure

        Azure  Docker Containers.

##  

 ,   :
-  Azure 
- Azure CLI  
- Docker Desktop  
- Git

##  

### 1.   Azure

1.  Azure CLI (  ):
   -  : https://docs.microsoft.com/en-us/cli/azure/install-azure-cli

2.  -Azure:
   ```
   az login
   ```

3.     :
   ```
   az account show
   ```
      :
   ```
   az account set --subscription "YOUR_SUBSCRIPTION_ID"
   ```

### 2.   

1.    `.env.azure`   :
   -     (`AZURE_SUBSCRIPTION_ID`)
   -     
   -      (`LOCATION`)

### 3.  

**/macOS**:
1.    :
   ```
   chmod +x azure-deploy.sh
   ```

2.  :
   ```
   ./azure-deploy.sh
   ```

**Windows (PowerShell)**:
1.  :
   ```
   .\deploy.ps1
   ```

### 4.  

1.   ,    :
   -  : `https://accountability-log-app.azurewebsites.net`
   - API: `https://accountability-log-app-api.azurewebsites.net`

2.        Azure:
   -  : https://portal.azure.com
   -  -App Services
   -   

##  

     :

1.     :
   ```
   az acr build --registry alaregistry --image ala-backend:latest ./backend
   az acr build --registry alaregistry --image ala-frontend:latest ./frontend
   ```

2.  -Web App:
   ```
   az webapp restart --resource-group ala-resource-group --name accountability-log-app-api
   az webapp restart --resource-group ala-resource-group --name accountability-log-app
   ```

##  

###   -Azure Container Registry
```
az acr login --name alaregistry
```

###     
1.     -DATABASE_URL
2.   -Firewall  

###   
    :
```
az webapp log tail --resource-group ala-resource-group --name accountability-log-app-api
```

##  

###   
```
az postgres flexible-server backup list --resource-group ala-resource-group --server-name ala-db
```

## 

         Azure.            .

================
File: backend/src/config/database.ts
================
import { Sequelize } from 'sequelize';
import logger from '../utils/logger';

// Database connection config
const DATABASE_URL = process.env.DATABASE_URL || 'postgres://postgres:postgres@localhost:5432/ala_db';

// Create Sequelize instance
const sequelize = new Sequelize(DATABASE_URL, {
  dialect: 'postgres',
  logging: false,
  dialectOptions: {
    ssl: process.env.ENABLE_SSL === 'true' ? {
      require: true,
      rejectUnauthorized: false
    } : false
  }
});

// Initialize database connection
export const initializeDatabase = async (): Promise<void> => {
  try {
    await sequelize.authenticate();
    logger.info('Database connection established successfully');
    
    // Sync models with database
    await sequelize.sync({ alter: process.env.NODE_ENV !== 'production' });
    logger.info('Database models synchronized');
  } catch (error) {
    logger.error(`Database connection error: ${error}`);
    throw error;
  }
};

export default sequelize;

================
File: backend/src/controllers/applicatorController.ts
================
import { Request, Response } from 'express';
import asyncHandler from 'express-async-handler';
import applicatorService from '../services/applicatorService';
import treatmentService from '../services/treatmentService';

// @desc    Validate an applicator barcode
// @route   POST /api/applicators/validate
// @access  Private
export const validateApplicator = asyncHandler(async (req: Request, res: Response) => {
  const { barcode, treatmentId } = req.body;
  
  if (!barcode || !treatmentId) {
    res.status(400);
    throw new Error('Barcode and treatmentId are required');
  }
  
  const validation = await applicatorService.validateApplicator(barcode, treatmentId);
  res.status(200).json(validation);
});

// @desc    Get an applicator by ID
// @route   GET /api/applicators/:id
// @access  Private
export const getApplicatorById = asyncHandler(async (req: Request, res: Response) => {
  const applicator = await applicatorService.getApplicatorById(req.params.id);
  
  // Get associated treatment to check permissions
  const treatment = await treatmentService.getTreatmentById(applicator.treatmentId);
  
  // Check if user has access to this treatment's applicators
  if (req.user.role !== 'admin' && treatment.userId !== req.user.id) {
    res.status(403);
    throw new Error('Not authorized to access this applicator');
  }
  
  res.status(200).json(applicator);
});

// @desc    Update an applicator
// @route   PATCH /api/treatments/:treatmentId/applicators/:id
// @access  Private
export const updateApplicator = asyncHandler(async (req: Request, res: Response) => {
  const { treatmentId, id } = req.params;
  
  // Verify the treatment exists and user has access
  const treatment = await treatmentService.getTreatmentById(treatmentId);
  
  if (req.user.role !== 'admin' && treatment.userId !== req.user.id) {
    res.status(403);
    throw new Error('Not authorized to modify this treatment');
  }
  
  // Get the applicator to verify it belongs to the specified treatment
  const applicator = await applicatorService.getApplicatorById(id);
  
  if (applicator.treatmentId !== treatmentId) {
    res.status(400);
    throw new Error('Applicator does not belong to the specified treatment');
  }
  
  // Use different update method based on treatment type
  let updatedApplicator;
  
  if (treatment.type === 'removal') {
    updatedApplicator = await applicatorService.updateApplicatorForRemoval(id, req.body, req.user.id);
  } else {
    updatedApplicator = await applicatorService.updateApplicator(id, req.body);
  }
  
  res.status(200).json(updatedApplicator);
});

// @desc    Calculate seed status for a removal treatment
// @route   GET /api/treatments/:treatmentId/seed-status
// @access  Private
export const getSeedStatus = asyncHandler(async (req: Request, res: Response) => {
  const { treatmentId } = req.params;
  
  // Verify the treatment exists and user has access
  const treatment = await treatmentService.getTreatmentById(treatmentId);
  
  if (req.user.role !== 'admin' && treatment.userId !== req.user.id) {
    res.status(403);
    throw new Error('Not authorized to access this treatment');
  }
  
  if (treatment.type !== 'removal') {
    res.status(400);
    throw new Error('Seed status is only relevant for removal treatments');
  }
  
  const seedStatus = await applicatorService.calculateSeedCountStatus(treatmentId);
  
  res.status(200).json(seedStatus);
});

================
File: backend/src/controllers/treatmentController.ts
================
import { Request, Response } from 'express';
import asyncHandler from 'express-async-handler';
import treatmentService from '../services/treatmentService';
import applicatorService from '../services/applicatorService';

// @desc    Get all treatments with optional filtering
// @route   GET /api/treatments
// @access  Private
export const getTreatments = asyncHandler(async (req: Request, res: Response) => {
  const { type, subjectId, site, date } = req.query;
  
  const treatments = await treatmentService.getTreatments({
    type: type as 'insertion' | 'removal' | undefined,
    subjectId: subjectId as string | undefined,
    site: site as string | undefined,
    date: date as string | undefined,
  }, req.user.id);
  
  res.status(200).json(treatments);
});

// @desc    Get a single treatment by ID
// @route   GET /api/treatments/:id
// @access  Private
export const getTreatmentById = asyncHandler(async (req: Request, res: Response) => {
  const treatment = await treatmentService.getTreatmentById(req.params.id);
  
  // Check if user has access to this treatment
  if (req.user.role !== 'admin' && treatment.userId !== req.user.id) {
    res.status(403);
    throw new Error('Not authorized to access this treatment');
  }
  
  res.status(200).json(treatment);
});

// @desc    Create a new treatment
// @route   POST /api/treatments
// @access  Private
export const createTreatment = asyncHandler(async (req: Request, res: Response) => {
  const treatment = await treatmentService.createTreatment(req.body, req.user.id);
  res.status(201).json(treatment);
});

// @desc    Update a treatment
// @route   PUT /api/treatments/:id
// @access  Private
export const updateTreatment = asyncHandler(async (req: Request, res: Response) => {
  const treatment = await treatmentService.getTreatmentById(req.params.id);
  
  // Check if user has access to update this treatment
  if (req.user.role !== 'admin' && treatment.userId !== req.user.id) {
    res.status(403);
    throw new Error('Not authorized to update this treatment');
  }
  
  const updatedTreatment = await treatmentService.updateTreatment(req.params.id, req.body);
  res.status(200).json(updatedTreatment);
});

// @desc    Complete a treatment
// @route   POST /api/treatments/:id/complete
// @access  Private
export const completeTreatment = asyncHandler(async (req: Request, res: Response) => {
  const treatment = await treatmentService.getTreatmentById(req.params.id);
  
  // Check if user has access to complete this treatment
  if (req.user.role !== 'admin' && treatment.userId !== req.user.id) {
    res.status(403);
    throw new Error('Not authorized to complete this treatment');
  }
  
  const completedTreatment = await treatmentService.completeTreatment(req.params.id, req.user.id);
  res.status(200).json(completedTreatment);
});

// @desc    Get applicators for a treatment
// @route   GET /api/treatments/:id/applicators
// @access  Private
export const getTreatmentApplicators = asyncHandler(async (req: Request, res: Response) => {
  const treatment = await treatmentService.getTreatmentById(req.params.id);
  
  // Check if user has access to this treatment
  if (req.user.role !== 'admin' && treatment.userId !== req.user.id) {
    res.status(403);
    throw new Error('Not authorized to access this treatment');
  }
  
  const applicators = await applicatorService.getApplicators(req.params.id);
  res.status(200).json(applicators);
});

// @desc    Add an applicator to a treatment
// @route   POST /api/treatments/:id/applicators
// @access  Private
export const addApplicator = asyncHandler(async (req: Request, res: Response) => {
  const treatment = await treatmentService.getTreatmentById(req.params.id);
  
  // Check if user has access to this treatment
  if (req.user.role !== 'admin' && treatment.userId !== req.user.id) {
    res.status(403);
    throw new Error('Not authorized to modify this treatment');
  }
  
  const applicator = await applicatorService.addApplicator(req.params.id, req.body, req.user.id);
  res.status(201).json(applicator);
});

// @desc    Export treatment data
// @route   GET /api/treatments/:id/export
// @access  Private
export const exportTreatment = asyncHandler(async (req: Request, res: Response) => {
  const { format = 'csv' } = req.query;
  const treatment = await treatmentService.getTreatmentById(req.params.id);
  
  // Check if user has access to this treatment
  if (req.user.role !== 'admin' && treatment.userId !== req.user.id) {
    res.status(403);
    throw new Error('Not authorized to access this treatment');
  }
  
  const applicators = await applicatorService.getApplicators(req.params.id);
  
  // Generate export data based on format
  if (format === 'csv') {
    // Generate CSV
    let csv = 'Serial Number,Seed Quantity,Usage Type,Insertion Time,Comments,Is Removed\n';
    
    applicators.forEach(app => {
      csv += `${app.serialNumber},${app.seedQuantity},${app.usageType},${app.insertionTime},${app.comments || ''},${app.isRemoved ? 'Yes' : 'No'}\n`;
    });
    
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename=treatment-${treatment.id}.csv`);
    res.send(csv);
  } else if (format === 'pdf') {
    // For PDF, in a real application, you would use a PDF generation library
    // For now, we'll just send a response indicating PDF generation
    res.status(200).send('PDF generation would happen here');
  } else {
    res.status(400);
    throw new Error('Unsupported export format');
  }
});

================
File: backend/src/dbInit.ts
================
import { initializeDatabase } from './config/database';
import { User, Treatment, Applicator } from './models';
import logger from './utils/logger';

const initializeDb = async () => {
  try {
    // Initialize database connection and sync models
    await initializeDatabase();
    logger.info('Database connection established and models synchronized');
    
    // Check if admin user exists
    const adminExists = await User.findOne({
      where: { role: 'admin' },
    });
    
    // If no admin user exists, create one
    if (!adminExists) {
      logger.info('Creating admin user');
      await User.create({
        name: 'Admin User',
        email: 'admin@example.com',
        phoneNumber: '+1234567890',
        role: 'admin',
        metadata: {
          sites: [], // Admin has access to all sites
          positionCode: 99 // Admin position code
        }
      });
    }
    
    // Create some test data for development
    if (process.env.NODE_ENV === 'development') {
      // Check if test hospital user exists
      const hospitalUserExists = await User.findOne({
        where: { role: 'hospital' },
      });
      
      // If no hospital user exists, create one
      if (!hospitalUserExists) {
        logger.info('Creating test hospital user');
        await User.create({
          name: 'Hospital User',
          email: 'hospital@example.com',
          phoneNumber: '+9876543210',
          role: 'hospital',
          metadata: {
            sites: ['100078'], // Example site
            positionCode: 50 // Non-admin position code
          }
        });
      }
      
      // Check if AlphaTau user exists
      const alphaTauUserExists = await User.findOne({
        where: { role: 'alphatau' },
      });
      
      // If no AlphaTau user exists, create one
      if (!alphaTauUserExists) {
        logger.info('Creating test AlphaTau user');
        await User.create({
          name: 'AlphaTau User',
          email: 'alphatau@example.com',
          phoneNumber: '+1122334455',
          role: 'alphatau',
          metadata: {
            sites: [], // Empty means all sites
            positionCode: 99 // Admin position code for AlphaTau staff
          }
        });
      }
    }
    
    logger.info('Database initialization completed successfully');
  } catch (error) {
    logger.error(`Database initialization error: ${error}`);
    process.exit(1);
  }
};

// Run the initialization
initializeDb();

================
File: backend/src/middleware/authMiddleware.ts
================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { User } from '../models';

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      user?: any;
    }
  }
}

// JWT Secret from environment variables
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Middleware to protect routes
export const protect = async (req: Request, res: Response, next: NextFunction) => {
  let token;

  // Check for token in Authorization header
  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    try {
      // Get token from header
      token = req.headers.authorization.split(' ')[1];

      // Verify token
      const decoded: any = jwt.verify(token, JWT_SECRET);

      // Get user from the token
      const user = await User.findByPk(decoded.id, {
        attributes: { exclude: ['verificationCode', 'verificationExpires'] },
      });

      if (!user) {
        res.status(401);
        throw new Error('Not authorized, user not found');
      }

      // Set user to req.user
      req.user = user;
      next();
    } catch (error) {
      res.status(401);
      throw new Error('Not authorized, invalid token');
    }
  }

  if (!token) {
    res.status(401);
    throw new Error('Not authorized, no token');
  }
};

// Middleware to restrict to specific roles
export const restrict = (...roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      res.status(401);
      throw new Error('Not authorized');
    }

    if (!roles.includes(req.user.role)) {
      res.status(403);
      throw new Error('Not authorized for this role');
    }

    next();
  };
};

================
File: backend/src/middleware/errorMiddleware.ts
================
import { Request, Response, NextFunction } from 'express';
import logger from '../utils/logger';

// Error handling middleware
export const errorHandler = (err: any, req: Request, res: Response, next: NextFunction) => {
  // Log error
  logger.error(`${err.message} - ${req.originalUrl} - ${req.method} - ${req.ip}`);
  
  // Handle specific error types
  if (err.name === 'SequelizeValidationError') {
    return res.status(400).json({
      success: false,
      message: 'Validation Error',
      errors: err.errors.map((e: any) => ({
        field: e.path,
        message: e.message,
      })),
    });
  }

  if (err.name === 'SequelizeUniqueConstraintError') {
    return res.status(409).json({
      success: false,
      message: 'Duplicate Entry',
      errors: err.errors.map((e: any) => ({
        field: e.path,
        message: e.message,
      })),
    });
  }

  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      message: 'Invalid token',
    });
  }

  // Log stack trace in development
  if (process.env.NODE_ENV === 'development') {
    logger.error(err.stack);
  }

  // Set status code
  const statusCode = res.statusCode === 200 ? 500 : res.statusCode;
  res.status(statusCode);
  
  // Send response
  res.json({
    success: false,
    message: err.message || 'Server Error',
    stack: process.env.NODE_ENV === 'production' ? null : err.stack,
  });
};

================
File: backend/src/middleware/notFoundMiddleware.ts
================
import { Request, Response, NextFunction } from 'express';

// 404 handler middleware
export const notFound = (req: Request, res: Response, next: NextFunction) => {
  const error = new Error(`Not Found - ${req.originalUrl}`);
  res.status(404);
  next(error);
};

================
File: backend/src/models/Applicator.ts
================
import { DataTypes, Model, Optional } from 'sequelize';
import sequelize from '../config/database';

// Applicator attributes interface
interface ApplicatorAttributes {
  id: string;
  serialNumber: string;
  seedQuantity: number;
  usageType: 'full' | 'faulty' | 'none';
  insertionTime: Date;
  comments: string | null;
  imagePath: string | null;
  isRemoved: boolean;
  removalComments: string | null;
  removalImagePath: string | null;
  removalTime: Date | null;
  treatmentId: string;
  addedBy: string;
  removedBy: string | null;
}

// For creating a new applicator
interface ApplicatorCreationAttributes extends Optional<ApplicatorAttributes, 'id' | 'comments' | 'imagePath' | 'isRemoved' | 'removalComments' | 'removalImagePath' | 'removalTime' | 'removedBy'> {}

class Applicator extends Model<ApplicatorAttributes, ApplicatorCreationAttributes> implements ApplicatorAttributes {
  public id!: string;
  public serialNumber!: string;
  public seedQuantity!: number;
  public usageType!: 'full' | 'faulty' | 'none';
  public insertionTime!: Date;
  public comments!: string | null;
  public imagePath!: string | null;
  public isRemoved!: boolean;
  public removalComments!: string | null;
  public removalImagePath!: string | null;
  public removalTime!: Date | null;
  public treatmentId!: string;
  public addedBy!: string;
  public removedBy!: string | null;

  // Timestamps
  public readonly createdAt!: Date;
  public readonly updatedAt!: Date;
}

Applicator.init(
  {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
    },
    serialNumber: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    seedQuantity: {
      type: DataTypes.INTEGER,
      allowNull: false,
      defaultValue: 0,
    },
    usageType: {
      type: DataTypes.ENUM('full', 'faulty', 'none'),
      allowNull: false,
      defaultValue: 'full',
    },
    insertionTime: {
      type: DataTypes.DATE,
      allowNull: false,
    },
    comments: {
      type: DataTypes.TEXT,
      allowNull: true,
    },
    imagePath: {
      type: DataTypes.STRING,
      allowNull: true,
    },
    isRemoved: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: false,
    },
    removalComments: {
      type: DataTypes.TEXT,
      allowNull: true,
    },
    removalImagePath: {
      type: DataTypes.STRING,
      allowNull: true,
    },
    removalTime: {
      type: DataTypes.DATE,
      allowNull: true,
    },
    treatmentId: {
      type: DataTypes.UUID,
      allowNull: false,
      references: {
        model: 'treatments',
        key: 'id',
      },
    },
    addedBy: {
      type: DataTypes.UUID,
      allowNull: false,
      references: {
        model: 'users',
        key: 'id',
      },
    },
    removedBy: {
      type: DataTypes.UUID,
      allowNull: true,
      references: {
        model: 'users',
        key: 'id',
      },
    },
  },
  {
    sequelize,
    modelName: 'Applicator',
    tableName: 'applicators',
    timestamps: true,
    indexes: [
      {
        fields: ['serialNumber'],
      },
      {
        fields: ['treatmentId'],
      },
    ],
  }
);

export default Applicator;

================
File: backend/src/models/index.ts
================
import User from './User';
import Treatment from './Treatment';
import Applicator from './Applicator';

// Define model associations
User.hasMany(Treatment, {
  foreignKey: 'userId',
  as: 'treatments',
});
Treatment.belongsTo(User, {
  foreignKey: 'userId',
  as: 'user',
});

Treatment.hasMany(Applicator, {
  foreignKey: 'treatmentId',
  as: 'applicators',
  onDelete: 'CASCADE',
});
Applicator.belongsTo(Treatment, {
  foreignKey: 'treatmentId',
  as: 'treatment',
});

User.hasMany(Applicator, {
  foreignKey: 'addedBy',
  as: 'addedApplicators',
});
Applicator.belongsTo(User, {
  foreignKey: 'addedBy',
  as: 'addedByUser',
});

User.hasMany(Applicator, {
  foreignKey: 'removedBy',
  as: 'removedApplicators',
});
Applicator.belongsTo(User, {
  foreignKey: 'removedBy',
  as: 'removedByUser',
});

export { User, Treatment, Applicator };

================
File: backend/src/models/Treatment.ts
================
import { DataTypes, Model, Optional } from 'sequelize';
import sequelize from '../config/database';

// Treatment attributes interface
interface TreatmentAttributes {
  id: string;
  type: 'insertion' | 'removal';
  subjectId: string;
  site: string;
  date: Date;
  isComplete: boolean;
  priorityId: string | null; // Reference to Priority system ID
  userId: string; // User who created/owns the treatment
  completedBy: string | null; // User who completed the treatment
  completedAt: Date | null; // When the treatment was completed
}

// For creating a new treatment
interface TreatmentCreationAttributes extends Optional<TreatmentAttributes, 'id' | 'isComplete' | 'priorityId' | 'completedBy' | 'completedAt'> {}

class Treatment extends Model<TreatmentAttributes, TreatmentCreationAttributes> implements TreatmentAttributes {
  public id!: string;
  public type!: 'insertion' | 'removal';
  public subjectId!: string;
  public site!: string;
  public date!: Date;
  public isComplete!: boolean;
  public priorityId!: string | null;
  public userId!: string;
  public completedBy!: string | null;
  public completedAt!: Date | null;

  // Timestamps
  public readonly createdAt!: Date;
  public readonly updatedAt!: Date;

  // Associations
  public readonly applicators?: any[];
}

Treatment.init(
  {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
    },
    type: {
      type: DataTypes.ENUM('insertion', 'removal'),
      allowNull: false,
    },
    subjectId: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    site: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    date: {
      type: DataTypes.DATE,
      allowNull: false,
    },
    isComplete: {
      type: DataTypes.BOOLEAN,
      allowNull: false,
      defaultValue: false,
    },
    priorityId: {
      type: DataTypes.STRING,
      allowNull: true,
    },
    userId: {
      type: DataTypes.UUID,
      allowNull: false,
      references: {
        model: 'users',
        key: 'id',
      },
    },
    completedBy: {
      type: DataTypes.UUID,
      allowNull: true,
      references: {
        model: 'users',
        key: 'id',
      },
    },
    completedAt: {
      type: DataTypes.DATE,
      allowNull: true,
    },
  },
  {
    sequelize,
    modelName: 'Treatment',
    tableName: 'treatments',
    timestamps: true,
    indexes: [
      {
        fields: ['subjectId'],
      },
      {
        fields: ['date'],
      },
      {
        fields: ['type'],
      },
    ],
  }
);

export default Treatment;

================
File: backend/src/routes/authRoutes.ts
================
import express from 'express';
import {
  requestVerificationCode,
  verifyCode,
  resendVerificationCode,
  validateToken,
} from '../controllers/authController';
import { protect } from '../middleware/authMiddleware';

const router = express.Router();

// Public routes
router.post('/request-code', requestVerificationCode);
router.post('/verify', verifyCode);
router.post('/resend-code', resendVerificationCode);

// Protected routes
router.post('/validate-token', protect, validateToken);

export default router;

================
File: backend/src/routes/healthRoutes.ts
================
import { Router } from 'express';

const router = Router();

router.get('/health', (_req, res) => res.status(200).json({ status: 'ok' }));

export default router;

================
File: backend/src/seedUser.js
================
const { User } = require('../dist/models');
const { initializeDatabase } = require('../dist/config/database');
const logger = require('../dist/utils/logger').default;

const seedUser = async () => {
  try {
    // Initialize database connection
    await initializeDatabase();

    // Check if test user already exists
    const existingUser = await User.findOne({
      where: { email: 'test@example.com' }
    });

    if (existingUser) {
      logger.info('Test user already exists');
      return;
    }

    // Create test user
    const user = await User.create({
      name: 'Test User',
      email: 'test@example.com',
      phoneNumber: '+1234567890',
      role: 'hospital'
    });

    logger.info(`Test user created with ID: ${user.id}`);
  } catch (error) {
    logger.error(`Error seeding user: ${error}`);
  } finally {
    process.exit(0);
  }
};

// Run the seed function
seedUser();

================
File: backend/src/seedUser.ts
================
import { User } from './models';
import { initializeDatabase } from './config/database';
import logger from './utils/logger';

const seedUser = async () => {
  try {
    // Initialize database connection
    await initializeDatabase();

    // Check if test user already exists
    const existingUser = await User.findOne({
      where: { email: 'test@example.com' }
    });

    if (existingUser) {
      logger.info('Test user already exists');
      return;
    }

    // Create test user
    const user = await User.create({
      name: 'Test User',
      email: 'test@example.com',
      phoneNumber: '+1234567890',
      role: 'hospital'
    });

    logger.info(`Test user created with ID: ${user.id}`);
  } catch (error) {
    logger.error(`Error seeding user: ${error}`);
  } finally {
    process.exit(0);
  }
};

// Run the seed function
seedUser();

================
File: backend/src/services/applicatorService.ts
================
import { Applicator, Treatment } from '../models';
import { Op } from 'sequelize';
import logger from '../utils/logger';

export const applicatorService = {
  // Get applicators for a treatment
  async getApplicators(treatmentId: string) {
    try {
      const applicators = await Applicator.findAll({
        where: { treatmentId },
        order: [['insertionTime', 'ASC']],
      });
      
      return applicators;
    } catch (error) {
      logger.error(`Error fetching applicators: ${error}`);
      throw error;
    }
  },

  // Get a single applicator by ID
  async getApplicatorById(id: string) {
    try {
      const applicator = await Applicator.findByPk(id);
      
      if (!applicator) {
        throw new Error('Applicator not found');
      }
      
      return applicator;
    } catch (error) {
      logger.error(`Error fetching applicator by ID: ${error}`);
      throw error;
    }
  },

  // Validate an applicator barcode for a treatment
  async validateApplicator(barcode: string, treatmentId: string) {
    try {
      // Check if the treatment exists
      const treatment = await Treatment.findByPk(treatmentId);
      
      if (!treatment) {
        return {
          valid: false,
          message: 'Treatment not found',
          requiresAdminApproval: false,
        };
      }
      
      // Check if applicator already exists in this treatment
      const existingInCurrentTreatment = await Applicator.findOne({
        where: { 
          serialNumber: barcode,
          treatmentId
        },
      });
      
      if (existingInCurrentTreatment) {
        return {
          valid: false,
          message: 'This applicator was already scanned for this treatment.',
          requiresAdminApproval: false,
          applicator: existingInCurrentTreatment,
        };
      }
      
      // Check if applicator exists in Applicators Serial Numbers DB
      const existingApplicator = await Applicator.findOne({
        where: { serialNumber: barcode },
      });
      
      if (existingApplicator) {
        // Check usage type
        if (existingApplicator.usageType === 'none') {
          return {
            valid: false,
            message: 'This applicator was scanned with status "No use".',
            requiresAdminApproval: true,
          };
        }
        
        // Check if tied to another treatment
        if (existingApplicator.treatmentId !== treatmentId) {
          return {
            valid: false,
            message: 'This applicator is intended for another treatment.',
            requiresAdminApproval: true,
          };
        }
      } else {
        // If not found, try to import applicator lists from treatments at the same site in past 24 hours
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        
        const recentTreatments = await Treatment.findAll({
          where: {
            site: treatment.site,
            date: {
              [Op.gte]: yesterday
            },
            id: {
              [Op.ne]: treatmentId
            }
          }
        });
        
        // Check all applicators from recent treatments
        for (const recentTreatment of recentTreatments) {
          const recentApplicators = await Applicator.findAll({
            where: { treatmentId: recentTreatment.id }
          });
          
          const matchingApplicator = recentApplicators.find(app => app.serialNumber === barcode);
          
          if (matchingApplicator) {
            return {
              valid: false,
              message: 'This applicator is intended for another treatment.',
              requiresAdminApproval: true,
            };
          }
        }
        
        // If still not found, default message
        return {
          valid: false,
          message: 'You are not allowed to use this applicator for this treatment.',
          requiresAdminApproval: true,
        };
      }
      
      // If all checks pass, the applicator is valid
      return {
        valid: true,
        message: 'Applicator validated successfully',
        requiresAdminApproval: false,
      };
    } catch (error) {
      logger.error(`Error validating applicator: ${error}`);
      throw error;
    }
  },

  // Add an applicator to a treatment with validation
  async addApplicator(treatmentId: string, data: any, userId: string) {
    try {
      const treatment = await Treatment.findByPk(treatmentId);
      
      if (!treatment) {
        throw new Error('Treatment not found');
      }
      
      if (treatment.isComplete) {
        throw new Error('Cannot add applicator to a completed treatment');
      }
      
      // Validate required fields
      if (!data.serialNumber) {
        throw new Error('Serial number is required');
      }
      
      if (!data.usageType) {
        throw new Error('Usage type is required');
      }
      
      // Validate usage type
      if (!['full', 'faulty', 'none'].includes(data.usageType)) {
        throw new Error('Invalid usage type. Must be "full", "faulty", or "none"');
      }
      
      // If usage type is "faulty", comments are required
      if (data.usageType === 'faulty' && !data.comments) {
        throw new Error('Comments are required for faulty applicators');
      }
      
      // Create the applicator
      const applicator = await Applicator.create({
        ...data,
        treatmentId,
        addedBy: userId,
        insertionTime: data.insertionTime || new Date(),
        seedQuantity: data.seedQuantity || 0,
        isRemoved: false,
      });
      
      return applicator;
    } catch (error) {
      logger.error(`Error adding applicator: ${error}`);
      throw error;
    }
  },

  // Update applicator with validation for removal treatment
  async updateApplicatorForRemoval(id: string, data: any, userId: string) {
    try {
      const applicator = await Applicator.findByPk(id);
      
      if (!applicator) {
        throw new Error('Applicator not found');
      }
      
      const treatment = await Treatment.findByPk(applicator.treatmentId);
      
      if (!treatment) {
        throw new Error('Treatment not found');
      }
      
      if (treatment.isComplete) {
        throw new Error('Cannot update applicator in a completed treatment');
      }
      
      if (treatment.type !== 'removal') {
        throw new Error('This method is only for removal treatments');
      }
      
      // Update applicator
      const updateData: any = {
        ...data,
      };
      
      // If marking as removed, set removal time and removed by
      if (data.isRemoved === true && !applicator.isRemoved) {
        updateData.removalTime = new Date();
        updateData.removedBy = userId;
      }
      
      await applicator.update(updateData);
      
      return applicator;
    } catch (error) {
      logger.error(`Error updating applicator for removal: ${error}`);
      throw error;
    }
  },
  
  // Calculate seed count status for a removal treatment
  async calculateSeedCountStatus(treatmentId: string) {
    try {
      const applicators = await Applicator.findAll({
        where: { treatmentId }
      });
      
      const totalSeeds = applicators.reduce((sum, app) => sum + app.seedQuantity, 0);
      const removedSeeds = applicators.reduce((sum, app) => 
        app.isRemoved ? sum + app.seedQuantity : sum, 0
      );
      
      return {
        totalSeeds,
        removedSeeds,
        complete: totalSeeds === removedSeeds,
        status: totalSeeds === removedSeeds ? 'complete' : 'incomplete',
      };
    } catch (error) {
      logger.error(`Error calculating seed count status: ${error}`);
      throw error;
    }
  },
  
  // Regular update function
  async updateApplicator(id: string, data: any) {
    try {
      const applicator = await Applicator.findByPk(id);
      
      if (!applicator) {
        throw new Error('Applicator not found');
      }
      
      await applicator.update(data);
      
      return applicator;
    } catch (error) {
      logger.error(`Error updating applicator: ${error}`);
      throw error;
    }
  },
};

export default applicatorService;

================
File: backend/src/services/treatmentService.ts
================
import { Treatment, Applicator, User } from '../models';
import { Op } from 'sequelize';
import logger from '../utils/logger';
import priorityService from './priorityService';

interface TreatmentFilterParams {
  type?: 'insertion' | 'removal';
  subjectId?: string;
  site?: string;
  date?: string;
}

export const treatmentService = {
  // Get treatments with optional filtering
  async getTreatments(params: TreatmentFilterParams, userId?: string) {
    try {
      // First, check database for existing treatments
      const whereClause: any = {};
      
      if (params.type) {
        whereClause.type = params.type;
      }
      
      if (params.subjectId) {
        whereClause.subjectId = params.subjectId;
      }
      
      if (params.site) {
        whereClause.site = params.site;
      }
      
      if (params.date) {
        whereClause.date = {
          [Op.gte]: new Date(params.date),
          [Op.lt]: new Date(new Date(params.date).getTime() + 24 * 60 * 60 * 1000) // Add 1 day
        };
      }
      
      // If userId provided and not admin, filter by user
      let userFilter = {};
      if (userId) {
        const user = await User.findByPk(userId);
        if (user && user.role !== 'admin') {
          // For hospital and alphatau users, filter by user or site permissions
          const userSites = user.metadata?.sites || [];
          userFilter = {
            [Op.or]: [
              { userId },
              { site: { [Op.in]: userSites } }
            ]
          };
        }
      }
      
      // Get database treatments
      const dbTreatments = await Treatment.findAll({
        where: {
          ...whereClause,
          ...userFilter
        },
        order: [['date', 'DESC']],
      });
      
      // For removal treatments, apply the 14-20 day window rule
      if (params.type === 'removal') {
        const today = new Date();
        const filteredDbTreatments = dbTreatments.filter(treatment => {
          const insertionTreatment = dbTreatments.find(t => 
            t.type === 'insertion' && 
            t.subjectId === treatment.subjectId && 
            t.site === treatment.site
          );
          
          if (!insertionTreatment) return false;
          
          const insertionDate = new Date(insertionTreatment.date);
          const daysSinceInsertion = Math.floor((today.getTime() - insertionDate.getTime()) / (1000 * 60 * 60 * 24));
          
          return daysSinceInsertion >= 14 && daysSinceInsertion <= 20;
        });
        
        return filteredDbTreatments;
      }
      
      // Check if we need to fetch from Priority
      if (dbTreatments.length > 0) {
        return dbTreatments;
      }
      
      // If no treatments in DB, try to fetch from Priority
      const user = userId ? await User.findByPk(userId) : null;
      const userSites = user?.metadata?.sites || [];
      
      // Only fetch from Priority if we have site information
      if (userSites.length > 0) {
        const priorityTreatments = await priorityService.getTreatmentsForSites(userSites, params);
        
        // Save treatments to our database if they don't exist already
        for (const treatment of priorityTreatments) {
          await Treatment.findOrCreate({
            where: {
              priorityId: treatment.id,
              subjectId: treatment.subjectId,
              site: treatment.site,
              type: treatment.type
            },
            defaults: {
              ...treatment,
              userId: userId || null,
              date: new Date(treatment.date),
            }
          });
        }
        
        return priorityTreatments;
      }
      
      return dbTreatments;
    } catch (error) {
      logger.error(`Error fetching treatments: ${error}`);
      throw error;
    }
  },

  // Get a single treatment by ID
  async getTreatmentById(id: string) {
    try {
      const treatment = await Treatment.findByPk(id, {
        include: [
          {
            model: Applicator,
            as: 'applicators',
          },
          {
            model: User,
            as: 'user',
            attributes: ['id', 'name', 'email', 'phoneNumber', 'role'],
          },
        ],
      });
      
      if (!treatment) {
        throw new Error('Treatment not found');
      }
      
      return treatment;
    } catch (error) {
      logger.error(`Error fetching treatment by ID: ${error}`);
      throw error;
    }
  },

  // Create a new treatment
  async createTreatment(data: any, userId: string) {
    try {
      const treatment = await Treatment.create({
        ...data,
        userId,
      });
      
      // Update Priority system if needed
      if (process.env.SYNC_WITH_PRIORITY === 'true') {
        try {
          const priorityResult = await priorityService.updatePriorityWithTreatment({
            ...data,
            id: treatment.id
          });
          
          // Update treatment with Priority ID
          if (priorityResult.success) {
            await treatment.update({
              priorityId: priorityResult.priorityId
            });
          }
        } catch (priorityError) {
          logger.error(`Error syncing with Priority: ${priorityError}`);
          // Proceed without Priority sync in case of error
        }
      }
      
      return treatment;
    } catch (error) {
      logger.error(`Error creating treatment: ${error}`);
      throw error;
    }
  },

  // Update an existing treatment
  async updateTreatment(id: string, data: any) {
    try {
      const treatment = await Treatment.findByPk(id);
      
      if (!treatment) {
        throw new Error('Treatment not found');
      }
      
      // If treatment is already complete, prevent updates
      if (treatment.isComplete && !data.isComplete) {
        throw new Error('Cannot update a completed treatment');
      }
      
      // Validate time window
      const timeWindowValidation = await this.validateTreatmentTimeWindow(id);
      if (!timeWindowValidation.valid) {
        throw new Error(timeWindowValidation.message);
      }
      
      await treatment.update(data);
      
      // Update Priority system if needed
      if (process.env.SYNC_WITH_PRIORITY === 'true' && treatment.priorityId) {
        try {
          await priorityService.updatePriorityWithTreatment({
            ...data,
            id: treatment.id,
            priorityId: treatment.priorityId
          });
        } catch (priorityError) {
          logger.error(`Error syncing with Priority: ${priorityError}`);
          // Proceed without Priority sync in case of error
        }
      }
      
      return treatment;
    } catch (error) {
      logger.error(`Error updating treatment: ${error}`);
      throw error;
    }
  },

  // Complete a treatment
  async completeTreatment(id: string, userId: string) {
    try {
      const treatment = await Treatment.findByPk(id);
      
      if (!treatment) {
        throw new Error('Treatment not found');
      }
      
      if (treatment.isComplete) {
        throw new Error('Treatment is already complete');
      }
      
      // For removal treatments, check seed count
      if (treatment.type === 'removal') {
        const applicators = await Applicator.findAll({
          where: { treatmentId: id }
        });
        
        const totalSeeds = applicators.reduce((sum, app) => sum + app.seedQuantity, 0);
        const removedSeeds = applicators.reduce((sum, app) => 
          app.isRemoved ? sum + app.seedQuantity : sum, 0
        );
        
        // If not all seeds are accounted for, log a warning
        if (totalSeeds !== removedSeeds) {
          logger.warn(`Treatment ${id} completed with missing seeds: ${totalSeeds - removedSeeds} seeds unaccounted for`);
        }
      }
      
      await treatment.update({
        isComplete: true,
        completedBy: userId,
        completedAt: new Date(),
      });
      
      // Update Priority system if needed
      if (process.env.SYNC_WITH_PRIORITY === 'true' && treatment.priorityId) {
        try {
          await priorityService.updatePriorityWithTreatment({
            ...treatment.toJSON(),
            isComplete: true,
            completedBy: userId,
            completedAt: new Date(),
            priorityId: treatment.priorityId
          });
        } catch (priorityError) {
          logger.error(`Error syncing with Priority: ${priorityError}`);
          // Proceed without Priority sync in case of error
        }
      }
      
      return treatment;
    } catch (error) {
      logger.error(`Error completing treatment: ${error}`);
      throw error;
    }
  },
  
  // Specific method for time window validation
  async validateTreatmentTimeWindow(treatmentId: string) {
    try {
      const treatment = await Treatment.findByPk(treatmentId);
      
      if (!treatment) {
        throw new Error('Treatment not found');
      }
      
      const today = new Date();
      const treatmentDate = new Date(treatment.date);
      const daysSinceTreatment = Math.floor((today.getTime() - treatmentDate.getTime()) / (1000 * 60 * 60 * 24));
      
      // Standard window is 21 days (14 days + 7-day extension)
      if (daysSinceTreatment > 21) {
        return {
          valid: false,
          message: 'This treatment cannot be modified after 21 days'
        };
      }
      
      // Special rule for day after insertion
      if (treatment.type === 'insertion' && daysSinceTreatment === 1) {
        // Check if user is hospital staff or Alpha Tau
        const user = await User.findByPk(treatment.userId);
        if (user && (user.role === 'hospital' || user.role === 'alphatau')) {
          return {
            valid: true,
            message: 'Hospital staff and Alpha Tau personnel can edit the day after insertion'
          };
        }
      }
      
      return {
        valid: true,
        message: 'Treatment is within the editable time window'
      };
    } catch (error) {
      logger.error(`Error validating treatment time window: ${error}`);
      throw error;
    }
  },
};

export default treatmentService;

================
File: backend/src/utils/logger.ts
================
import winston from 'winston';

// Define log format
const logFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.printf(({ timestamp, level, message }) => {
    return `${timestamp} [${level.toUpperCase()}]: ${message}`;
  })
);

// Create logger instance
const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: logFormat,
  transports: [
    // Write logs to console
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        logFormat
      )
    }),
    // Write logs to file in production
    ...(process.env.NODE_ENV === 'production'
      ? [
          new winston.transports.File({
            filename: 'logs/error.log',
            level: 'error',
            maxsize: 5242880, // 5MB
            maxFiles: 5,
          }),
          new winston.transports.File({
            filename: 'logs/combined.log',
            maxsize: 5242880, // 5MB
            maxFiles: 5,
          }),
        ]
      : []),
  ],
});

export default logger;

================
File: backend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "**/*.test.ts"]
}

================
File: debug.sh
================
#!/bin/bash

echo "Running ALA Application Debug Script..."

# Check if Node.js is installed
if ! command -v node &> /dev/null; then
  echo "Error: Node.js is not installed or not in PATH"
  echo "Please install Node.js and try again"
  exit 1
fi

# Create logs directory if it doesn't exist
mkdir -p logs

# Install axios if not already installed
echo "Checking for required packages..."
if ! npm list axios --json &> /dev/null; then
  echo "Installing axios package..."
  npm install axios --no-save
fi

// Run the debug script
echo "Starting debug checks..."
node scripts/debug.js

echo ""
echo "Debug complete. Log file created at logs/debug.log"
echo ""
echo "NEXT STEPS:"
echo "1. Check the Docker containers are running:  docker ps"
echo "2. View container logs:                     docker-compose -f docker-compose.dev.yml logs -f"
echo "3. Access frontend at:                      http://localhost:3000"
echo "4. Check backend health at:                 http://localhost:5000/api/health"
echo ""

# Make the script executable
chmod +x debug.sh

================
File: docker-compose.prod.yml
================
version: '3.8'

services:
  # Backend API
  api:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: ala-api-prod
    restart: unless-stopped
    depends_on:
      - db
    environment:
      - NODE_ENV=production
      - PORT=5000
      - DATABASE_URL=postgres://postgres:postgres@db:5432/ala_db
      - ENABLE_SSL=false
      - JWT_SECRET=your-jwt-secret-key-change-in-production
      - PRIORITY_URL=https://t.eu.priority-connect.online/odata/Priority/tabbtbc6.ini/test24/
    ports:
      - "5000:5000"
    networks:
      - ala-network
    volumes:
      - api-logs:/usr/src/app/logs

  # Frontend application
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: ala-frontend-prod
    restart: unless-stopped
    environment:
      - API_URL=http://api:5000
    ports:
      - "80:80"
    depends_on:
      - api
    networks:
      - ala-network

  # PostgreSQL Database
  db:
    image: postgres:15-alpine
    container_name: ala-db-prod
    restart: unless-stopped
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=ala_db
    ports:
      - "5432:5432"
    networks:
      - ala-network
    volumes:
      - postgres-data-prod:/var/lib/postgresql/data

networks:
  ala-network:
    driver: bridge

volumes:
  postgres-data-prod:
  api-logs:

================
File: docs/ALA-GIT-GUIDE.md
================
# ALA Project Git Workflow Guide

This guide provides practical instructions for developers working on the Accountability Log Application (ALA) to properly use our Git workflow system.

## Getting Started

Our project uses a structured Git workflow with separate branches for development and production:

- `main` branch: Contains production-ready code
- `develop` branch: Integration branch for all new features
- Feature branches: For developing new features
- Hotfix branches: For urgent production fixes

## Daily Development Workflow

### 1. Starting a New Feature

When you begin work on a new feature, always start by creating a properly named feature branch:

```bash
# Navigate to your project directory
cd C:\path\to\ala-improved

# For Windows
scripts\new-feature.bat my-feature-name

# For Linux/Mac
./scripts/new-feature.sh my-feature-name
```

This automatically:
- Checks out the latest develop branch
- Creates a new feature branch with the proper naming convention
- Sets up the branch for pushing to GitHub

### 2. Working on Your Feature

As you develop your feature:

- Make frequent, small commits with clear messages
- Keep your feature branch updated with the latest changes from develop:
  ```bash
  git checkout develop
  git pull
  git checkout feature/my-feature-name
  git merge develop
  ```

- Test your changes locally using the development Docker configuration:
  ```bash
  docker-compose -f docker-compose.dev.yml up -d
  ```

### 3. Completing Your Feature

When your feature is complete:

1. Ensure all tests pass locally
2. Push your branch to GitHub:
   ```bash
   git push -u origin feature/my-feature-name
   ```

3. Create a pull request from your feature branch to `develop` on GitHub
4. Request code review from team members
5. After approval, merge your pull request into the develop branch

The CI/CD pipeline will automatically deploy your changes to the development environment when merged to develop.

## Promoting to Production

When the team decides the code in develop is ready for production:

```bash
# For Windows
scripts\release.bat [version]

# For Linux/Mac
./scripts/release.sh [version]
```

The version parameter is optional - if omitted, the current date will be used as the version.

This script will:
1. Ensure all tests pass
2. Merge develop into main
3. Create a version tag
4. Push changes to GitHub
5. Trigger the production deployment workflow

**Important**: The production deployment requires manual approval in GitHub Actions before the actual deployment occurs.

## Handling Production Issues

If you discover a critical issue in production that needs immediate attention:

```bash
# For Windows
scripts\new-hotfix.bat issue-description

# For Linux/Mac
./scripts/new-hotfix.sh issue-description
```

This will:
1. Create a hotfix branch from main
2. Set you up to fix the issue

After fixing the issue:
1. Push your hotfix branch
2. Create a pull request to main
3. After approval and merging, the fix will be deployed to production
4. Don't forget to also merge the hotfix back to develop:
   ```bash
   git checkout develop
   git pull
   git merge hotfix/issue-description
   git push
   ```

## Deployment Process

Our project has automated deployment using GitHub Actions:

1. **Development Environment**:
   - Automatically deployed when code is merged to the develop branch
   - Running at: [dev.ala-app.example.com](https://dev.ala-app.example.com)

2. **Production Environment**:
   - Requires manual approval after automated tests pass
   - Database backup is created before each deployment
   - Running at: [ala-app.example.com](https://ala-app.example.com)

## Database Migrations

When making changes that require database schema updates:

1. Always create proper migration scripts
2. Test migrations thoroughly in development
3. Document the migration in pull request notes
4. Database backups are automatically created before production deployments

## Docker Images

Our application uses Docker for consistent environments:

- Development: Uses volumes for live code changes
- Production: Builds optimized images with version tags

To test with Docker in development:
```bash
docker-compose -f docker-compose.dev.yml up -d
```

## Troubleshooting

### Common Issues

1. **"Cannot push to remote" errors**:
   - Ensure you have the latest code: `git pull origin develop`
   - Check your GitHub credentials

2. **Merge conflicts**:
   - Pull the latest develop branch
   - Resolve conflicts in your code editor
   - Complete the merge: `git merge --continue`

3. **Failed deployments**:
   - Check the GitHub Actions logs for details
   - Fix issues in your feature branch and create a new PR

### Getting Help

If you encounter issues with the Git workflow:

1. Check the detailed documentation in `docs/GIT-WORKFLOW.md`
2. Contact the DevOps team for assistance
3. For urgent production issues, alert the on-call developer

## Best Practices

1. Never commit directly to main or develop branches
2. Keep feature branches small and focused
3. Use descriptive commit messages
4. Run tests locally before pushing
5. Always create pull requests for code review
6. Document API changes or configuration requirements in PR descriptions
7. Keep the develop branch deployable at all times

Following these guidelines will help maintain code quality and ensure smooth deployments from development to production.

================
File: docs/GIT-WORKFLOW.md
================
# Git Workflow Documentation for ALA Project

This document outlines the Git workflow process for the Accountability Log Application (ALA), explaining how to manage code from development to production environments.

## Branching Strategy

Our project follows a modified GitFlow workflow with the following branch structure:

- **`main`**: The production branch. All code here is deployable to the production environment.
- **`develop`**: The integration branch for new features. This branch represents the development environment.
- **`feature/feature-name`**: Feature branches for new development work.
- **`hotfix/issue-name`**: Hotfix branches for urgent production fixes.

## Development Workflow

### Starting a New Feature

1. Make sure you're on the develop branch:
   ```
   git checkout develop
   git pull origin develop
   ```

2. Create a new feature branch:
   ```
   ./scripts/new-feature.bat my-new-feature
   ```
   (On Linux/Mac: `./scripts/new-feature.sh my-new-feature`)

3. Make your changes to implement the feature.

4. Commit your changes:
   ```
   git add .
   git commit -m "Description of your changes"
   ```

5. Push your feature branch to the remote repository:
   ```
   git push -u origin feature/my-new-feature
   ```

6. Create a pull request from your feature branch to the `develop` branch.

7. After code review, merge the pull request into the `develop` branch.

### Deploying to Development Environment

When code is merged to the `develop` branch, the CI/CD pipeline will automatically:

1. Run tests on the code
2. If tests pass, deploy to the development environment

You can also manually trigger this workflow from GitHub Actions.

## Production Workflow

### Releasing to Production

When the code in development is ready for production:

1. Use the release script:
   ```
   ./scripts/release.bat 1.2.3
   ```
   (On Linux/Mac: `./scripts/release.sh 1.2.3`)

   If you don't specify a version, the current date will be used.

2. The script will:
   - Ensure the `develop` branch is up to date
   - Run tests
   - Merge `develop` into `main`
   - Create a version tag
   - Push changes to the remote repository

3. The production deployment workflow will start automatically. It requires:
   - Passing automated tests
   - Manual approval in GitHub Actions
   - After approval, it will deploy to production

### Hotfixes for Production Issues

If you need to fix a critical issue in production:

1. Create a hotfix branch:
   ```
   ./scripts/new-hotfix.bat critical-bug-fix
   ```
   (On Linux/Mac: `./scripts/new-hotfix.sh critical-bug-fix`)

2. Make your changes to fix the issue.

3. Commit your changes:
   ```
   git add .
   git commit -m "Fix critical issue"
   ```

4. Push your hotfix branch:
   ```
   git push -u origin hotfix/critical-bug-fix
   ```

5. Create a pull request from your hotfix branch to the `main` branch.

6. After code review, merge the pull request into the `main` branch.

7. Don't forget to also merge the changes back to the `develop` branch:
   ```
   git checkout develop
   git pull origin develop
   git merge hotfix/critical-bug-fix
   git push origin develop
   ```

## Docker Image Tags

Our Docker images follow a specific tagging convention:

- Development images: `ala-frontend:dev`, `ala-backend:dev`
- Production images: `ala-frontend:1.2.3`, `ala-backend:1.2.3` (with version numbers)

## Database Considerations

Before deploying to production, the CI/CD pipeline will:
1. Create a backup of the production database
2. Apply any new migrations

If you need to roll back a production deployment, use the database backup to restore to the previous state.

## Secrets and Environment Variables

GitHub Actions secrets are used for:
- SSH deployment keys
- Server IP addresses
- Project paths
- Database credentials

These must be configured in your GitHub repository settings under Secrets and Variables > Actions.

Required secrets for the workflow:
- `DEV_SSH_PRIVATE_KEY`: SSH key for the development server
- `DEV_SERVER_IP`: IP address of the development server
- `DEV_SERVER_USER`: Username for development server SSH access
- `DEV_PROJECT_PATH`: Path to the project directory on the development server
- `PROD_SSH_PRIVATE_KEY`: SSH key for the production server
- `PROD_SERVER_IP`: IP address of the production server
- `PROD_SERVER_USER`: Username for production server SSH access
- `PROD_PROJECT_PATH`: Path to the project directory on the production server

## Local Development

For local development, follow these practices:

1. Always create feature branches from the latest `develop` branch
2. Regularly pull changes from the `develop` branch to stay up-to-date
3. Test your changes with Docker using the development configuration:
   ```
   docker-compose -f docker-compose.dev.yml up -d
   ```
4. Create pull requests early to get early feedback (use the "Draft PR" feature)

================
File: docs/IMPROVEMENTS.md
================
# Accountability Log Application Improvements

This document outlines the key improvements made in the redesigned Accountability Log Application compared to the original implementation.

## Architecture Improvements

1. **Separation of Concerns**
   - Clearly separated frontend and backend codebases
   - Organized code into logical layers (presentation, application, data access)
   - Implemented proper MVC pattern on the backend

2. **Modern Tech Stack**
   - Updated to latest React (18) with TypeScript for type safety
   - Implemented Tailwind CSS for consistent styling
   - Used Vite for faster development experience

3. **State Management**
   - Replaced complex prop drilling with React Context API
   - Implemented custom hooks for business logic reuse
   - Added proper authentication state management

4. **Code Organization**
   - Structured components by feature/domain
   - Created reusable UI components
   - Added consistent naming conventions

## Feature Improvements

1. **Authentication**
   - Improved verification code system with timeout and resend functionality
   - Added proper security measures (JWT, protected routes)
   - Implemented role-based access control

2. **Treatment Management**
   - Enhanced treatment selection with better filtering
   - Improved data validation and error handling
   - Added support for multi-step workflows

3. **Barcode Scanning**
   - Better error handling and validation
   - Added manual entry fallback option
   - Improved user feedback during scanning

4. **Offline Support**
   - Implemented local storage for offline operation
   - Added synchronization when connection is restored
   - Provided clear visual indicators for offline mode

5. **User Interface**
   - Consistent design language across the application
   - Responsive layouts for both phones and tablets
   - Improved accessibility and usability

6. **Admin Features**
   - Added comprehensive dashboard with statistics
   - Improved system logs and monitoring
   - Added configuration management

## Technical Improvements

1. **Performance**
   - Optimized component rendering with React best practices
   - Implemented proper data fetching strategies
   - Added caching for frequent operations

2. **Security**
   - Implemented proper authentication and authorization
   - Added input validation and sanitization
   - Set up secure HTTP headers

3. **Maintainability**
   - Added comprehensive documentation
   - Implemented consistent code style with ESLint and Prettier
   - Created a structured branching strategy

4. **Testing**
   - Set up testing infrastructure with Jest and React Testing Library
   - Added unit tests for critical components
   - Implemented E2E testing for key workflows

5. **Deployment**
   - Configured environment-specific builds
   - Added proper CI/CD setup
   - Implemented logging and monitoring

## Data Storage Improvements

1. **Database**
   - Switched to PostgreSQL for better reliability
   - Implemented proper data models with relationships
   - Added indexes for performance optimization

2. **API Design**
   - Created RESTful API endpoints
   - Implemented proper error handling
   - Added validation middleware

3. **Integration**
   - Improved Priority system integration
   - Added proper error handling for external services
   - Implemented retry mechanisms for failed operations

## Next Steps

1. **Further Enhancements**
   - Implement real-time notifications
   - Add more comprehensive reporting features
   - Enhance offline capabilities

2. **Additional Features**
   - Multi-language support
   - Dark mode theme
   - Advanced analytics dashboard

3. **Infrastructure**
   - Set up monitoring and alerting
   - Implement automated backups
   - Add disaster recovery procedures

================
File: frontend/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Accountability Log Application (ALA)" />
    <title>Accountability Log Application</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: frontend/package.json
================
{
  "name": "ala-frontend",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "format": "prettier --write \"src/**/*.{ts,tsx,css}\"",
    "preview": "vite preview",
    "test": "vitest run",
    "test:watch": "vitest"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.3.4",
    "axios": "^1.7.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "date-fns": "^3.4.0",
    "html5-qrcode": "^2.3.8",
    "lucide-react": "^0.407.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.51.0",
    "react-router-dom": "^6.22.3",
    "tailwind-merge": "^2.4.0",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.22.4",
    "zustand": "^4.5.2"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^14.2.1",
    "@testing-library/user-event": "^14.5.2",
    "@types/babel__generator": "^7.27.0",
    "@types/babel__template": "^7.4.4",
    "@types/babel__traverse": "^7.20.7",
    "@types/node": "^20.11.25",
    "@types/prop-types": "^15.7.14",
    "@types/react": "^18.2.48",
    "@types/react-dom": "^18.2.18",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.2.0",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.18",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "jsdom": "^24.0.0",
    "postcss": "^8.4.35",
    "prettier": "^3.3.2",
    "prettier-plugin-tailwindcss": "^0.6.5",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.3.3",
    "vite": "^5.2.3",
    "vitest": "^1.3.1"
  }
}

================
File: frontend/postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: frontend/src/components/FileExplorer.tsx
================
import React, { useState } from 'react';

// Note: This component requires Lucide React to be installed
// If it's not already part of your project, install it with:
// npm install lucide-react

interface FileNode {
  name: string;
  path?: string;
  highlight?: boolean;
  children?: FileNode[];
}

/**
 * FileExplorer component to visualize project structure
 * Can be used for documentation or development guides
 */
const FileExplorer: React.FC = () => {
  const [expandedFolders, setExpandedFolders] = useState({
    root: true,
    backend: true,
    'backend/src': true,
    'frontend': true,
    'frontend/src': true,
    'frontend/src/services': true,
    'scripts': true,
    'azure': false,
    'docs': false
  });

  const toggleFolder = (folder: string) => {
    setExpandedFolders({
      ...expandedFolders,
      [folder]: !expandedFolders[folder]
    });
  };

  const getFileIcon = (fileName: string) => {
    const extension = fileName.split('.').pop()?.toLowerCase() || '';
    
    // Use CSS classes and check if lucide icons are available
    // Fallback to simple text if icons aren't available
    switch(extension) {
      case 'ts':
      case 'tsx':
        return <span className="text-blue-500 mr-2">[TS]</span>;
      case 'js':
      case 'jsx':
        return <span className="text-yellow-500 mr-2">[JS]</span>;
      case 'json':
        return <span className="text-green-500 mr-2">[JSON]</span>;
      case 'md':
        return <span className="text-gray-500 mr-2">[MD]</span>;
      case 'yml':
      case 'yaml':
        return <span className="text-purple-500 mr-2">[YML]</span>;
      case 'bat':
      case 'sh':
        return <span className="text-red-500 mr-2">[SH]</span>;
      case 'css':
        return <span className="text-blue-400 mr-2">[CSS]</span>;
      case 'html':
        return <span className="text-orange-500 mr-2">[HTML]</span>;
      default:
        return <span className="text-gray-400 mr-2">[FILE]</span>;
    }
  };

  const renderFiles = (files: FileNode[], indent = 0) => {
    return files.map((file, index) => {
      const isFolder = file.children !== undefined;
      const path = file.path || file.name;
      const isExpanded = isFolder && expandedFolders[path];
      
      return (
        <div key={index}>
          <div 
            className={`flex items-center py-1 hover:bg-gray-100 ${file.highlight ? 'bg-yellow-100' : ''}`}
            style={{ paddingLeft: `${indent * 16}px` }}
          >
            {isFolder ? (
              <span 
                className="flex items-center cursor-pointer" 
                onClick={() => toggleFolder(path)}
              >
                {isExpanded ? 
                  <span className="text-gray-500 mr-1"></span> : 
                  <span className="text-gray-500 mr-1"></span>
                }
                <span className="text-yellow-600 mr-2"></span>
                <span className="text-sm">{file.name}</span>
              </span>
            ) : (
              <span className="flex items-center">
                <span className="w-4"></span>
                {getFileIcon(file.name)}
                <span className="text-sm">{file.name}</span>
              </span>
            )}
          </div>
          
          {isFolder && isExpanded && renderFiles(file.children, indent + 1)}
        </div>
      );
    });
  };

  // Define the project structure
  const projectFiles: FileNode[] = [
    {
      name: 'ala-improved',
      path: 'root',
      children: [
        {
          name: '.env.docker',
          highlight: false
        },
        {
          name: '.gitignore',
          highlight: false
        },
        {
          name: 'azure',
          children: [
            { name: 'azure-deploy.sh' },
            { name: 'deploy.ps1' },
            { name: 'README.md' }
          ]
        },
        {
          name: 'backend',
          children: [
            { name: 'Dockerfile' },
            { name: 'package.json' },
            { 
              name: 'src',
              path: 'backend/src',
              children: [
                {
                  name: 'config',
                  children: [
                    { name: 'database.ts' }
                  ]
                },
                {
                  name: 'controllers',
                  children: [
                    { name: 'authController.ts', highlight: true }
                  ]
                },
                {
                  name: 'middleware',
                  children: [
                    { name: 'authMiddleware.ts' },
                    { name: 'errorMiddleware.ts' },
                    { name: 'notFoundMiddleware.ts' }
                  ]
                },
                {
                  name: 'models',
                  children: [
                    { name: 'Applicator.ts' },
                    { name: 'index.ts' },
                    { name: 'Treatment.ts' },
                    { name: 'User.ts' }
                  ]
                },
                {
                  name: 'routes',
                  children: [
                    { name: 'adminRoutes.ts' },
                    { name: 'applicatorRoutes.ts' },
                    { name: 'authRoutes.ts', highlight: true },
                    { name: 'treatmentRoutes.ts' }
                  ]
                },
                {
                  name: 'utils',
                  children: [
                    { name: 'logger.ts' }
                  ]
                },
                { name: 'seedUser.js' },
                { name: 'seedUser.ts' },
                { name: 'server.ts', highlight: true }
              ]
            },
            { name: 'tsconfig.json' }
          ]
        },
        {
          name: 'debug.bat',
          highlight: true
        },
        {
          name: 'debug.sh',
          highlight: true
        },
        {
          name: 'docker-compose.dev.yml',
          highlight: true
        },
        {
          name: 'docker-compose.prod.yml'
        },
        {
          name: 'docker-compose.yml'
        },
        {
          name: 'docs',
          children: [
            { name: 'IMPROVEMENTS.md' }
          ]
        },
        {
          name: 'frontend',
          children: [
            { name: 'Dockerfile' },
            { name: 'Dockerfile.dev' },
            { name: 'index.html' },
            { name: 'nginx.conf' },
            { name: 'package.json' },
            { name: 'postcss.config.js' },
            { 
              name: 'src',
              path: 'frontend/src',
              children: [
                { name: 'App.tsx' },
                {
                  name: 'components',
                  children: [
                    { name: 'FileExplorer.tsx', highlight: true },
                    { name: 'Layout.tsx' },
                    { name: 'ProtectedRoute.tsx' }
                  ]
                },
                {
                  name: 'context',
                  children: [
                    { name: 'AuthContext.tsx' },
                    { name: 'TreatmentContext.tsx' }
                  ]
                },
                { name: 'index.css' },
                { name: 'main.tsx' },
                {
                  name: 'pages',
                  children: [
                    { 
                      name: 'Admin',
                      children: [
                        { name: 'Dashboard.tsx' }
                      ]
                    },
                    { 
                      name: 'Auth',
                      children: [
                        { name: 'LoginPage.tsx' },
                        { name: 'VerificationPage.tsx' }
                      ]
                    },
                    { 
                      name: 'Treatment',
                      children: [
                        { name: 'ApplicatorInformation.tsx' },
                        { name: 'ScanQRCode.tsx' },
                        { name: 'SeedRemoval.tsx' },
                        { name: 'TreatmentSelection.tsx' },
                        { name: 'UseList.tsx' }
                      ]
                    }
                  ]
                },
                {
                  name: 'services',
                  path: 'frontend/src/services',
                  children: [
                    { name: 'api.ts', highlight: true },
                    { name: 'authService.ts', highlight: true },
                    { name: 'priorityService.ts', highlight: true },
                    { name: 'treatmentService.ts' }
                  ]
                }
              ]
            },
            { name: 'tailwind.config.js' },
            { name: 'tsconfig.json' },
            { name: 'tsconfig.node.json' },
            { name: 'vite.config.ts' }
          ]
        },
        {
          name: 'README.md'
        },
        {
          name: 'restart.bat',
          highlight: true
        },
        {
          name: 'scripts',
          children: [
            { name: 'debug.js', highlight: true }
          ]
        }
      ]
    }
  ];

  return (
    <div className="w-full h-full border rounded-md">
      <div className="bg-gray-100 border-b py-2 px-4 flex items-center">
        <span className="font-medium"> ALA Application Files</span>
      </div>
      <div className="p-2 bg-white overflow-auto" style={{height: "500px"}}>
        {renderFiles(projectFiles)}
      </div>
      <div className="bg-gray-100 border-t py-2 px-4 text-xs text-gray-500">
        Files highlighted in yellow were modified to fix the issues
      </div>
    </div>
  );
};

export default FileExplorer;

================
File: frontend/src/components/ProtectedRoute.tsx
================
import { Navigate, Outlet } from 'react-router-dom';
import { useAuth } from '@/context/AuthContext';

const ProtectedRoute = () => {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    return (
      <div className="flex h-screen items-center justify-center">
        <div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent"></div>
      </div>
    );
  }

  return isAuthenticated ? <Outlet /> : <Navigate to="/login" replace />;
};

export default ProtectedRoute;

================
File: frontend/src/context/AuthContext.tsx
================
import { createContext, useState, useContext, useEffect, ReactNode } from 'react';
import { useNavigate } from 'react-router-dom';
import { authService } from '@/services/authService';

interface User {
  id: string;
  email: string;
  phoneNumber: string;
  role: 'hospital' | 'alphatau' | 'admin';
  name: string;
  positionCode?: string;
  custName?: string;
}

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  error: string | null;
  isAuthenticated: boolean;
  login: (identifier: string) => Promise<void>;
  verify: (code: string) => Promise<void>;
  logout: () => void;
  clearError: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [loginIdentifier, setLoginIdentifier] = useState<string>('');
  const navigate = useNavigate();

  useEffect(() => {
    // Check for user in local storage on initial load
    const checkAuth = async () => {
      try {
        const storedUser = localStorage.getItem('user');
        const token = localStorage.getItem('token');
        
        if (storedUser && token) {
          // Validate token with backend
          const valid = await authService.validateToken(token);
          
          if (valid) {
            setUser(JSON.parse(storedUser));
          } else {
            // Token invalid, remove from storage
            localStorage.removeItem('user');
            localStorage.removeItem('token');
          }
        }
      } catch (err) {
        console.error('Auth check error:', err);
      } finally {
        setIsLoading(false);
      }
    };

    checkAuth();
  }, []);

  const login = async (identifier: string) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const result = await authService.requestVerificationCode(identifier);
      
      if (!result.success) {
        setError(result.message || 'Login failed. Please try again.');
        return;
      }
      
      // Store the identifier for verification
      setLoginIdentifier(identifier);
      sessionStorage.setItem('loginIdentifier', identifier);
      
      // Navigate to verification page
      navigate('/verify');
    } catch (err: any) {
      setError(err.message || 'Login failed. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const verify = async (code: string) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const result = await authService.verifyCode(loginIdentifier, code);
      setUser(result.user);
      
      // Store auth data in localStorage for persistence
      localStorage.setItem('user', JSON.stringify(result.user));
      localStorage.setItem('token', result.token);
      
      navigate('/treatment/select');
    } catch (err: any) {
      setError(err.message || 'Verification failed. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const logout = () => {
    setUser(null);
    localStorage.removeItem('user');
    localStorage.removeItem('token');
    sessionStorage.removeItem('priorityUserData');
    navigate('/login');
  };

  const clearError = () => {
    setError(null);
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        error,
        isAuthenticated: !!user,
        login,
        verify,
        logout,
        clearError
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

================
File: frontend/src/context/TreatmentContext.tsx
================
import { createContext, useState, useContext, ReactNode } from 'react';

interface Treatment {
  id: string;
  type: 'insertion' | 'removal';
  subjectId: string;
  site: string;
  date: string;
  isComplete: boolean;
}

interface Applicator {
  id: string;
  serialNumber: string;
  seedQuantity: number;
  usageType: 'full' | 'faulty' | 'none';
  insertionTime: string;
  comments?: string;
  image?: string;
  isRemoved?: boolean;
  removalComments?: string;
  removalImage?: string;
}

interface TreatmentContextType {
  currentTreatment: Treatment | null;
  applicators: Applicator[];
  currentApplicator: Applicator | null;
  setTreatment: (treatment: Treatment) => void;
  addApplicator: (applicator: Applicator) => void;
  updateApplicator: (id: string, data: Partial<Applicator>) => void;
  setCurrentApplicator: (applicator: Applicator | null) => void;
  removeApplicator: (id: string) => void;
  clearTreatment: () => void;
  totalSeeds: number;
  removedSeeds: number;
}

const TreatmentContext = createContext<TreatmentContextType | undefined>(undefined);

export function TreatmentProvider({ children }: { children: ReactNode }) {
  const [currentTreatment, setCurrentTreatment] = useState<Treatment | null>(null);
  const [applicators, setApplicators] = useState<Applicator[]>([]);
  const [currentApplicator, setCurrentApplicator] = useState<Applicator | null>(null);

  const setTreatment = (treatment: Treatment) => {
    setCurrentTreatment(treatment);
    // Clear applicators when changing treatments
    if (treatment.type === 'insertion') {
      setApplicators([]);
    }
  };

  const addApplicator = (applicator: Applicator) => {
    setApplicators((prev) => [...prev, applicator]);
  };

  const updateApplicator = (id: string, data: Partial<Applicator>) => {
    setApplicators((prev) => 
      prev.map((app) => app.id === id ? { ...app, ...data } : app)
    );
  };

  const removeApplicator = (id: string) => {
    setApplicators((prev) => prev.filter((app) => app.id !== id));
  };

  const clearTreatment = () => {
    setCurrentTreatment(null);
    setApplicators([]);
    setCurrentApplicator(null);
  };

  // Calculate totals for removal treatment
  const totalSeeds = applicators.reduce((sum, app) => sum + app.seedQuantity, 0);
  const removedSeeds = applicators.reduce((sum, app) => 
    app.isRemoved ? sum + app.seedQuantity : sum, 0
  );

  return (
    <TreatmentContext.Provider
      value={{
        currentTreatment,
        applicators,
        currentApplicator,
        setTreatment,
        addApplicator,
        updateApplicator,
        setCurrentApplicator,
        removeApplicator,
        clearTreatment,
        totalSeeds,
        removedSeeds
      }}
    >
      {children}
    </TreatmentContext.Provider>
  );
}

export function useTreatment() {
  const context = useContext(TreatmentContext);
  if (context === undefined) {
    throw new Error('useTreatment must be used within a TreatmentProvider');
  }
  return context;
}

================
File: frontend/src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 142.1 76.2% 36.3%;
    --primary-foreground: 355.7 100% 97.3%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 142.1 76.2% 36.3%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 20 14.3% 4.1%;
    --foreground: 0 0% 95%;
    --card: 24 9.8% 10%;
    --card-foreground: 0 0% 95%;
    --popover: 0 0% 9%;
    --popover-foreground: 0 0% 95%;
    --primary: 142.1 70.6% 45.3%;
    --primary-foreground: 144.9 80.4% 10%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 15%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 85.7% 97.3%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 142.4 71.8% 29.2%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}

================
File: frontend/src/main.tsx
================
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';

import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

================
File: frontend/src/pages/Admin/Dashboard.tsx
================
import { useState, useEffect } from 'react';
import Layout from '@/components/Layout';
import { useAuth } from '@/context/AuthContext';

const Dashboard = () => {
  const { user } = useAuth();
  const [activeTab, setActiveTab] = useState<'stats' | 'logs' | 'config'>('stats');
  
  // In a real app, we would fetch these stats from an API
  const stats = {
    totalTreatments: 156,
    completedTreatments: 142,
    pendingTreatments: 14,
    totalApplicators: 843,
    users: 27,
  };
  
  useEffect(() => {
    if (user?.role !== 'admin') {
      // Redirect non-admin users
      window.location.href = '/treatment/select';
    }
  }, [user]);

  if (user?.role !== 'admin') {
    return (
      <Layout title="Admin Dashboard">
        <div className="flex items-center justify-center py-10">
          <p>You do not have permission to access this page.</p>
        </div>
      </Layout>
    );
  }

  return (
    <Layout title="Admin Dashboard">
      <div className="space-y-6">
        <div className="mb-4 border-b border-gray-200">
          <nav className="-mb-px flex space-x-8">
            <button
              onClick={() => setActiveTab('stats')}
              className={`whitespace-nowrap border-b-2 px-1 py-4 text-sm font-medium ${
                activeTab === 'stats'
                  ? 'border-primary text-primary'
                  : 'border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700'
              }`}
            >
              Statistics
            </button>
            <button
              onClick={() => setActiveTab('logs')}
              className={`whitespace-nowrap border-b-2 px-1 py-4 text-sm font-medium ${
                activeTab === 'logs'
                  ? 'border-primary text-primary'
                  : 'border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700'
              }`}
            >
              System Logs
            </button>
            <button
              onClick={() => setActiveTab('config')}
              className={`whitespace-nowrap border-b-2 px-1 py-4 text-sm font-medium ${
                activeTab === 'config'
                  ? 'border-primary text-primary'
                  : 'border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700'
              }`}
            >
              Configuration
            </button>
          </nav>
        </div>

        {activeTab === 'stats' && (
          <div>
            <h2 className="mb-6 text-xl font-medium">System Statistics</h2>
            
            <div className="grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-3">
              <div className="overflow-hidden rounded-lg bg-white shadow">
                <div className="p-5">
                  <div className="flex items-center">
                    <div className="flex-shrink-0">
                      <svg className="h-6 w-6 text-primary" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                      </svg>
                    </div>
                    <div className="ml-5 w-0 flex-1">
                      <dl>
                        <dt className="truncate text-sm font-medium text-gray-500">Total Treatments</dt>
                        <dd>
                          <div className="text-lg font-medium text-gray-900">{stats.totalTreatments}</div>
                        </dd>
                      </dl>
                    </div>
                  </div>
                </div>
                <div className="bg-gray-50 px-5 py-3">
                  <div className="text-sm">
                    <span className="font-medium text-green-600">{stats.completedTreatments} completed</span>
                    <span className="mx-2 text-gray-500"></span>
                    <span className="font-medium text-yellow-600">{stats.pendingTreatments} pending</span>
                  </div>
                </div>
              </div>

              <div className="overflow-hidden rounded-lg bg-white shadow">
                <div className="p-5">
                  <div className="flex items-center">
                    <div className="flex-shrink-0">
                      <svg className="h-6 w-6 text-primary" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4" />
                      </svg>
                    </div>
                    <div className="ml-5 w-0 flex-1">
                      <dl>
                        <dt className="truncate text-sm font-medium text-gray-500">Total Applicators</dt>
                        <dd>
                          <div className="text-lg font-medium text-gray-900">{stats.totalApplicators}</div>
                        </dd>
                      </dl>
                    </div>
                  </div>
                </div>
                <div className="bg-gray-50 px-5 py-3">
                  <div className="text-sm">
                    <span className="font-medium text-gray-600">Used in treatments</span>
                  </div>
                </div>
              </div>

              <div className="overflow-hidden rounded-lg bg-white shadow">
                <div className="p-5">
                  <div className="flex items-center">
                    <div className="flex-shrink-0">
                      <svg className="h-6 w-6 text-primary" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" />
                      </svg>
                    </div>
                    <div className="ml-5 w-0 flex-1">
                      <dl>
                        <dt className="truncate text-sm font-medium text-gray-500">Registered Users</dt>
                        <dd>
                          <div className="text-lg font-medium text-gray-900">{stats.users}</div>
                        </dd>
                      </dl>
                    </div>
                  </div>
                </div>
                <div className="bg-gray-50 px-5 py-3">
                  <div className="text-sm">
                    <span className="font-medium text-gray-600">Active in system</span>
                  </div>
                </div>
              </div>
            </div>

            <div className="mt-8 rounded-lg border bg-white p-6 shadow-sm">
              <h3 className="mb-4 text-lg font-medium">Recent Activity</h3>
              <p className="text-gray-500">Activity chart would go here...</p>
            </div>
          </div>
        )}

        {activeTab === 'logs' && (
          <div>
            <h2 className="mb-6 text-xl font-medium">System Logs</h2>
            
            <div className="rounded-lg border bg-white p-6 shadow-sm">
              <div className="mb-4 flex items-center justify-between">
                <div>
                  <h3 className="text-lg font-medium">Event Log</h3>
                  <p className="text-sm text-gray-500">System events and notifications</p>
                </div>
                <div>
                  <select className="rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-primary focus:outline-none focus:ring-primary">
                    <option value="all">All Events</option>
                    <option value="error">Errors</option>
                    <option value="warning">Warnings</option>
                    <option value="info">Info</option>
                  </select>
                </div>
              </div>

              <div className="overflow-hidden rounded-lg border">
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th scope="col" className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                        Timestamp
                      </th>
                      <th scope="col" className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                        Level
                      </th>
                      <th scope="col" className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                        Message
                      </th>
                      <th scope="col" className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                        User
                      </th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-gray-200 bg-white">
                    {/* Sample log entries */}
                    <tr>
                      <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                        2025-05-10 09:45:21
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm">
                        <span className="inline-flex rounded-full bg-green-100 px-2 text-xs font-semibold leading-5 text-green-800">
                          INFO
                        </span>
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-500">
                        User logged in successfully
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                        john.doe@example.com
                      </td>
                    </tr>
                    <tr>
                      <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                        2025-05-10 08:32:15
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm">
                        <span className="inline-flex rounded-full bg-yellow-100 px-2 text-xs font-semibold leading-5 text-yellow-800">
                          WARNING
                        </span>
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-500">
                        Multiple verification attempts detected
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                        sarah.smith@example.com
                      </td>
                    </tr>
                    <tr>
                      <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                        2025-05-09 17:12:53
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm">
                        <span className="inline-flex rounded-full bg-red-100 px-2 text-xs font-semibold leading-5 text-red-800">
                          ERROR
                        </span>
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-500">
                        Failed to connect to Priority system
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                        System
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        )}

        {activeTab === 'config' && (
          <div>
            <h2 className="mb-6 text-xl font-medium">System Configuration</h2>
            
            <div className="rounded-lg border bg-white p-6 shadow-sm">
              <h3 className="mb-4 text-lg font-medium">Application Settings</h3>

              <div className="space-y-6">
                <div>
                  <h4 className="mb-2 text-sm font-medium text-gray-700">Priority System Integration</h4>
                  <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
                    <div>
                      <label htmlFor="priority-url" className="block text-xs font-medium text-gray-500">API URL</label>
                      <input
                        id="priority-url"
                        type="text"
                        value="https://t.eu.priority-connect.online/odata/Priority/tabbtbc6.ini/test24/"
                        className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm"
                      />
                    </div>
                    <div>
                      <label htmlFor="priority-timeout" className="block text-xs font-medium text-gray-500">Request Timeout (ms)</label>
                      <input
                        id="priority-timeout"
                        type="number"
                        value={30000}
                        className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm"
                      />
                    </div>
                  </div>
                </div>

                <div>
                  <h4 className="mb-2 text-sm font-medium text-gray-700">Verification Settings</h4>
                  <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
                    <div>
                      <label htmlFor="code-expiry" className="block text-xs font-medium text-gray-500">Code Expiry (seconds)</label>
                      <input
                        id="code-expiry"
                        type="number"
                        value={600}
                        className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm"
                      />
                    </div>
                    <div>
                      <label htmlFor="max-attempts" className="block text-xs font-medium text-gray-500">Max Failed Attempts</label>
                      <input
                        id="max-attempts"
                        type="number"
                        value={3}
                        className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm"
                      />
                    </div>
                  </div>
                </div>

                <div>
                  <h4 className="mb-2 text-sm font-medium text-gray-700">Treatment Configuration</h4>
                  <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
                    <div>
                      <label htmlFor="removal-min-days" className="block text-xs font-medium text-gray-500">Min Days for Removal</label>
                      <input
                        id="removal-min-days"
                        type="number"
                        value={14}
                        className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm"
                      />
                    </div>
                    <div>
                      <label htmlFor="removal-max-days" className="block text-xs font-medium text-gray-500">Max Days for Removal</label>
                      <input
                        id="removal-max-days"
                        type="number"
                        value={20}
                        className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm"
                      />
                    </div>
                  </div>
                </div>

                <div className="pt-4">
                  <button
                    type="button"
                    className="rounded-md bg-primary px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2"
                  >
                    Save Configuration
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </Layout>
  );
};

export default Dashboard;

================
File: frontend/src/pages/Auth/LoginPage.tsx
================
import { useState } from 'react';
import { useAuth } from '@/context/AuthContext';

const LoginPage = () => {
  const { login, error, clearError, isLoading } = useAuth();
  const [identifier, setIdentifier] = useState('');
  const [identifierType, setIdentifierType] = useState('email');
  const [successMessage, setSuccessMessage] = useState('');
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (identifier) {
      try {
        await login(identifier);
      } catch (err) {
        console.error("Login error:", err);
      }
    }
  };

  // For demo purposes only - quick login with test account
  const handleTestLogin = async () => {
    const testEmail = 'tzufitc@alphatau.com';
    setIdentifier(testEmail);
    
    try {
      await login(testEmail);
      setSuccessMessage(`Verification code sent to ${testEmail}. For testing, the code is always 123456.`);
      setTimeout(() => {
        window.location.href = '/verify';
      }, 2000);
    } catch (err) {
      console.error("Demo login error:", err);
    }
  };

  return (
    <div className="flex min-h-screen flex-col items-center justify-center bg-gray-50 p-4">
      <div className="w-full max-w-md">
        <div className="mb-8 text-center">
          <img 
            src="/logo.png" 
            alt="AlphaTau Logo" 
            className="mx-auto mb-4 h-16 w-auto"
          />
          <h1 className="text-2xl font-bold text-gray-900">
            Accountability Log System
          </h1>
          <p className="mt-2 text-gray-600">
            Log in with your email or phone number
          </p>
          
          {/* Demo button */}
          <button
            onClick={handleTestLogin}
            className="mt-4 rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white"
          >
            Quick Demo Login
          </button>
          
          {successMessage && (
            <div className="mt-4 rounded-md bg-green-50 p-3 text-sm text-green-700">
              {successMessage}
            </div>
          )}
        </div>

        {error && (
          <div className="mb-4 rounded-md bg-red-50 p-4 text-sm text-red-700">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                  <path
                    fillRule="evenodd"
                    d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                    clipRule="evenodd"
                  />
                </svg>
              </div>
              <div className="ml-3">
                <p>{error}</p>
              </div>
              <div className="ml-auto pl-3">
                <div className="-mx-1.5 -my-1.5">
                  <button
                    onClick={clearError}
                    className="inline-flex rounded-md p-1.5 text-red-500 hover:bg-red-100 focus:outline-none"
                  >
                    <span className="sr-only">Dismiss</span>
                    <svg className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                      <path
                        fillRule="evenodd"
                        d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                        clipRule="evenodd"
                      />
                    </svg>
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <div className="mb-2 flex rounded-md shadow-sm">
              <button
                type="button"
                onClick={() => setIdentifierType('email')}
                className={`relative inline-flex items-center rounded-l-md border px-4 py-2 text-sm font-medium ${
                  identifierType === 'email'
                    ? 'border-primary bg-primary text-white'
                    : 'border-gray-300 bg-gray-50 text-gray-700 hover:bg-gray-100'
                }`}
              >
                Email
              </button>
              <button
                type="button"
                onClick={() => setIdentifierType('phone')}
                className={`relative -ml-px inline-flex items-center rounded-r-md border px-4 py-2 text-sm font-medium ${
                  identifierType === 'phone'
                    ? 'border-primary bg-primary text-white'
                    : 'border-gray-300 bg-gray-50 text-gray-700 hover:bg-gray-100'
                }`}
              >
                Phone
              </button>
            </div>
            <label
              htmlFor="identifier"
              className="block text-sm font-medium text-gray-700"
            >
              {identifierType === 'email' ? 'Email Address' : 'Phone Number'}
            </label>
            <div className="mt-1">
              <input
                id="identifier"
                name="identifier"
                type={identifierType === 'email' ? 'email' : 'tel'}
                autoComplete={identifierType === 'email' ? 'email' : 'tel'}
                required
                value={identifier}
                onChange={(e) => setIdentifier(e.target.value)}
                placeholder={identifierType === 'email' ? 'user@example.com' : '+972 50-000-0000'}
                className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm"
              />
            </div>
            {identifierType === 'email' && (
              <p className="mt-1 text-xs text-gray-500">
                Your email will be validated against the Priority system records.
              </p>
            )}
          </div>

          <div>
            <button
              type="submit"
              disabled={isLoading || !identifier}
              className="flex w-full justify-center rounded-md border border-transparent bg-primary px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 disabled:opacity-50"
            >
              {isLoading ? (
                <>
                  <svg className="mr-2 h-4 w-4 animate-spin" viewBox="0 0 24 24">
                    <circle
                      className="opacity-25"
                      cx="12"
                      cy="12"
                      r="10"
                      stroke="currentColor"
                      strokeWidth="4"
                    ></circle>
                    <path
                      className="opacity-75"
                      fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    ></path>
                  </svg>
                  {identifierType === 'email' ? 'Validating Email...' : 'Sending Code...'}
                </>
              ) : (
                'Send Verification Code'
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default LoginPage;

================
File: frontend/src/pages/ProjectDocPage.tsx
================
import React from 'react';
import FileExplorer from '../components/FileExplorer';

/**
 * Project documentation page with file structure
 */
const ProjectDocPage: React.FC = () => {
  return (
    <div className="max-w-screen-lg mx-auto p-6">
      <h1 className="text-2xl font-bold mb-6">ALA Project Documentation</h1>
      
      <div className="mb-8">
        <h2 className="text-xl font-semibold mb-3">Project Structure</h2>
        <FileExplorer />
      </div>
      
      <div className="mb-8">
        <h2 className="text-xl font-semibold mb-3">Recent Changes</h2>
        <div className="bg-white p-4 border rounded-md">
          <h3 className="font-medium mb-2">Fixed Issues:</h3>
          <ul className="list-disc ml-6 space-y-2">
            <li>
              <span className="font-medium">API Path Mismatch</span>
              <p className="text-sm text-gray-600">Fixed incorrect path in authService.ts resendVerificationCode method</p>
            </li>
            <li>
              <span className="font-medium">Priority API Integration</span>
              <p className="text-sm text-gray-600">Updated priorityService.ts to properly handle API connections</p>
            </li>
            <li>
              <span className="font-medium">TypeScript Errors</span>
              <p className="text-sm text-gray-600">Fixed type errors in server.ts route handling</p>
            </li>
            <li>
              <span className="font-medium">Debugging Tools</span>
              <p className="text-sm text-gray-600">Added scripts/debug.js, debug.bat, debug.sh, and restart.bat utilities</p>
            </li>
          </ul>
        </div>
      </div>
      
      <div className="mb-8">
        <h2 className="text-xl font-semibold mb-3">How to Run the Application</h2>
        <div className="bg-white p-4 border rounded-md">
          <h3 className="font-medium mb-2">Development Mode:</h3>
          <pre className="bg-gray-100 p-3 rounded my-2 overflow-x-auto">
            docker-compose -f docker-compose.dev.yml up -d
          </pre>
          
          <h3 className="font-medium mb-2 mt-4">Production Mode:</h3>
          <pre className="bg-gray-100 p-3 rounded my-2 overflow-x-auto">
            docker-compose -f docker-compose.prod.yml up -d
          </pre>
          
          <h3 className="font-medium mb-2 mt-4">Restart Containers:</h3>
          <pre className="bg-gray-100 p-3 rounded my-2 overflow-x-auto">
            .\restart.bat
          </pre>
          
          <h3 className="font-medium mb-2 mt-4">Debugging:</h3>
          <pre className="bg-gray-100 p-3 rounded my-2 overflow-x-auto">
            .\debug.bat
          </pre>
        </div>
      </div>
    </div>
  );
};

export default ProjectDocPage;

================
File: frontend/src/pages/Treatment/ApplicatorInformation.tsx
================
import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { format } from 'date-fns';
import Layout from '@/components/Layout';
import { useTreatment } from '@/context/TreatmentContext';
import { treatmentService } from '@/services/treatmentService';

const ApplicatorInformation = () => {
  const navigate = useNavigate();
  const { currentTreatment, currentApplicator, addApplicator, updateApplicator } = useTreatment();

  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [seedQuantity, setSeedQuantity] = useState(currentApplicator?.seedQuantity || 0);
  const [usageType, setUsageType] = useState<'full' | 'faulty' | 'none'>(
    currentApplicator?.usageType || 'full'
  );
  const [insertionTime, setInsertionTime] = useState<string>(
    currentApplicator
      ? format(new Date(currentApplicator.insertionTime), "yyyy-MM-dd'T'HH:mm")
      : format(new Date(), "yyyy-MM-dd'T'HH:mm")
  );
  const [comments, setComments] = useState<string>(currentApplicator?.comments || '');
  const [imagePreview, setImagePreview] = useState<string | undefined>(
    currentApplicator?.image || undefined
  );

  useEffect(() => {
    if (!currentTreatment || !currentApplicator) {
      navigate('/treatment/scan');
    }
  }, [currentTreatment, currentApplicator, navigate]);

  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];

      // Create preview
      const reader = new FileReader();
      reader.onloadend = () => {
        setImagePreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!currentTreatment || !currentApplicator) {
      setError('No treatment or applicator selected');
      return;
    }

    // Validate - if usage type is 'faulty', comments are required
    if (usageType === 'faulty' && !comments.trim()) {
      setError('Comments are required for faulty applicators');
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const applicatorData = {
        id: currentApplicator.id || '',
        serialNumber: currentApplicator.serialNumber,
        seedQuantity,
        usageType,
        insertionTime: new Date(insertionTime).toISOString(),
        comments: comments || undefined,
        image: imagePreview,
      };

      if (currentApplicator.id) {
        // Update existing applicator
        const updatedApplicator = await treatmentService.updateApplicator(
          currentTreatment.id,
          currentApplicator.id,
          applicatorData
        );
        updateApplicator(currentApplicator.id, updatedApplicator);
      } else {
        // Add new applicator
        const newApplicator = await treatmentService.addApplicator(
          currentTreatment.id,
          applicatorData
        );
        addApplicator(newApplicator);
      }

      // Navigate to the use list
      navigate('/treatment/list');
    } catch (err: any) {
      setError(err.message || 'Failed to save applicator information');
    } finally {
      setIsLoading(false);
    }
  };

  const handleCancel = () => {
    // Go back to scanner
    navigate('/treatment/scan');
  };

  if (!currentTreatment || !currentApplicator) {
    return (
      <Layout title='Applicator Information' showBackButton>
        <div className='flex items-center justify-center py-10'>
          <p>No applicator selected. Please scan an applicator first.</p>
        </div>
      </Layout>
    );
  }

  return (
    <Layout title='Applicator Information' showBackButton>
      <div className='mx-auto max-w-2xl space-y-6'>
        <div className='rounded-lg border bg-white p-4 shadow-sm'>
          <h2 className='mb-4 text-lg font-medium'>Treatment Information</h2>
          <div className='grid grid-cols-2 gap-4'>
            <div>
              <p className='text-sm text-gray-500'>Subject ID</p>
              <p className='font-medium'>{currentTreatment.subjectId}</p>
            </div>
            <div>
              <p className='text-sm text-gray-500'>Site</p>
              <p className='font-medium'>{currentTreatment.site}</p>
            </div>
            <div>
              <p className='text-sm text-gray-500'>Type</p>
              <p className='font-medium capitalize'>{currentTreatment.type}</p>
            </div>
            <div>
              <p className='text-sm text-gray-500'>Date</p>
              <p className='font-medium'>{new Date(currentTreatment.date).toLocaleDateString()}</p>
            </div>
          </div>
        </div>

        <div className='rounded-lg border bg-white p-4 shadow-sm'>
          <h2 className='mb-4 text-lg font-medium'>Applicator Details</h2>

          <div className='mb-4 rounded-md bg-blue-50 p-3 text-blue-800'>
            <div className='flex'>
              <div className='flex-shrink-0'>
                <svg className='h-5 w-5 text-blue-500' viewBox='0 0 20 20' fill='currentColor'>
                  <path
                    fillRule='evenodd'
                    d='M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z'
                    clipRule='evenodd'
                  />
                </svg>
              </div>
              <div className='ml-3 flex-1 md:flex md:justify-between'>
                <p className='text-sm'>
                  Serial Number:{' '}
                  <span className='font-semibold'>{currentApplicator.serialNumber}</span>
                </p>
              </div>
            </div>
          </div>

          {error && (
            <div className='mb-4 rounded-md bg-red-50 p-4 text-sm text-red-700'>{error}</div>
          )}

          <form onSubmit={handleSubmit} className='space-y-4'>
            <div>
              <label htmlFor='usageType' className='block text-sm font-medium text-gray-700'>
                Usage Type *
              </label>
              <select
                id='usageType'
                value={usageType}
                onChange={(e) => setUsageType(e.target.value as 'full' | 'faulty' | 'none')}
                className='mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm'
                required>
                <option value='full'>Full Use</option>
                <option value='faulty'>Faulty</option>
                <option value='none'>No Use</option>
              </select>
            </div>

            <div>
              <label htmlFor='seedQuantity' className='block text-sm font-medium text-gray-700'>
                Seed Quantity *
              </label>
              <input
                type='number'
                id='seedQuantity'
                value={seedQuantity}
                onChange={(e) => setSeedQuantity(parseInt(e.target.value) || 0)}
                min='0'
                className='mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm'
                required
              />
            </div>

            <div>
              <label htmlFor='insertionTime' className='block text-sm font-medium text-gray-700'>
                Insertion Time *
              </label>
              <input
                type='datetime-local'
                id='insertionTime'
                value={insertionTime}
                onChange={(e) => setInsertionTime(e.target.value)}
                className='mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm'
                required
              />
            </div>

            <div>
              <label htmlFor='comments' className='block text-sm font-medium text-gray-700'>
                Comments {usageType === 'faulty' && '*'}
              </label>
              <textarea
                id='comments'
                value={comments}
                onChange={(e) => setComments(e.target.value)}
                rows={3}
                className='mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm'
                required={usageType === 'faulty'}></textarea>
              {usageType === 'faulty' && (
                <p className='mt-1 text-sm text-red-500'>
                  Comments are required for faulty applicators
                </p>
              )}
            </div>

            <div>
              <label htmlFor='image' className='block text-sm font-medium text-gray-700'>
                Upload Image
              </label>
              <input
                type='file'
                id='image'
                accept='image/*'
                onChange={handleImageChange}
                className='mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm'
              />
              {imagePreview && (
                <div className='mt-2'>
                  <img
                    src={imagePreview}
                    alt='Preview'
                    className='h-40 w-auto rounded-md object-cover'
                  />
                </div>
              )}
            </div>

            <div className='flex justify-between pt-4'>
              <button
                type='button'
                onClick={handleCancel}
                className='rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2'>
                Cancel
              </button>
              <button
                type='submit'
                disabled={isLoading}
                className='rounded-md bg-primary px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 disabled:opacity-50'>
                {isLoading ? 'Saving...' : 'Save Applicator'}
              </button>
            </div>
          </form>
        </div>
      </div>
    </Layout>
  );
};

export default ApplicatorInformation;

================
File: frontend/src/pages/Treatment/ScanQRCode.tsx
================
import { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { Html5QrcodeScanner, Html5QrcodeSupportedFormats } from 'html5-qrcode';
import Layout from '@/components/Layout';
import { useTreatment } from '@/context/TreatmentContext';
import { treatmentService } from '@/services/treatmentService';

const ScanQRCode = () => {
  const { currentTreatment, setCurrentApplicator } = useTreatment();
  const navigate = useNavigate();

  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [manualEntry, setManualEntry] = useState(false);
  const [barcodeValue, setBarcodeValue] = useState('');

  const scannerRef = useRef<Html5QrcodeScanner | null>(null);
  const scannerDivRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!currentTreatment) {
      navigate('/treatment/select');
      return;
    }

    if (!manualEntry && scannerDivRef.current) {
      // Initialize the scanner
      scannerRef.current = new Html5QrcodeScanner(
        'qr-reader',
        {
          fps: 10,
          qrbox: 250,
          aspectRatio: 1.0,
          formatsToSupport: [
            Html5QrcodeSupportedFormats.QR_CODE,
            Html5QrcodeSupportedFormats.CODE_128,
            Html5QrcodeSupportedFormats.EAN_13,
            Html5QrcodeSupportedFormats.CODE_39,
          ],
        },
        false
      );

      scannerRef.current.render(onScanSuccess, onScanFailure);
    }

    return () => {
      if (scannerRef.current) {
        try {
          scannerRef.current.clear();
        } catch (err) {
          console.error('Error clearing scanner:', err);
        }
      }
    };
  }, [currentTreatment, manualEntry]);

  const onScanSuccess = async (decodedText: string) => {
    await handleBarcodeSubmit(decodedText);
  };

  const onScanFailure = (error: any) => {
    console.error('Scan failure:', error);
  };

  const handleBarcodeSubmit = async (code: string = barcodeValue) => {
    if (!code) {
      setError('Please enter a barcode');
      return;
    }

    if (!currentTreatment?.id) {
      setError('No treatment selected');
      navigate('/treatment/select');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Validate the barcode with the backend
      const validation = await treatmentService.validateApplicator(code, currentTreatment.id);

      if (!validation.valid && validation.requiresAdminApproval) {
        setError(`${validation.message} Admin approval required.`);
      } else if (!validation.valid) {
        setError(validation.message);
      } else if (validation.applicator) {
        // If validation returns an applicator object, use it
        setCurrentApplicator(validation.applicator);
        navigate('/treatment/applicator');
      } else {
        // If validation is successful but no applicator is returned,
        // create a new applicator with default values
        setCurrentApplicator({
          id: '', // Will be assigned by backend
          serialNumber: code,
          seedQuantity: 0, // Will be updated based on barcode
          usageType: 'full',
          insertionTime: new Date().toISOString(),
        });
        navigate('/treatment/applicator');
      }
    } catch (err: any) {
      setError(err.message || 'Failed to validate barcode');
    } finally {
      setLoading(false);
    }
  };

  const handleManualSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    handleBarcodeSubmit();
  };

  const toggleEntryMode = () => {
    setManualEntry(!manualEntry);
    setError(null);
  };

  return (
    <Layout title='Scan Applicator Barcode' showBackButton backPath='/treatment/select'>
      <div className='mx-auto max-w-2xl space-y-6'>
        <div className='rounded-lg border bg-white p-4 shadow-sm'>
          <h2 className='mb-4 text-lg font-medium'>Treatment Information</h2>
          {currentTreatment ? (
            <div className='grid grid-cols-2 gap-4'>
              <div>
                <p className='text-sm text-gray-500'>Subject ID</p>
                <p className='font-medium'>{currentTreatment.subjectId}</p>
              </div>
              <div>
                <p className='text-sm text-gray-500'>Site</p>
                <p className='font-medium'>{currentTreatment.site}</p>
              </div>
              <div>
                <p className='text-sm text-gray-500'>Type</p>
                <p className='font-medium capitalize'>{currentTreatment.type}</p>
              </div>
              <div>
                <p className='text-sm text-gray-500'>Date</p>
                <p className='font-medium'>
                  {new Date(currentTreatment.date).toLocaleDateString()}
                </p>
              </div>
            </div>
          ) : (
            <p>No treatment selected</p>
          )}
        </div>

        <div className='rounded-lg border bg-white p-4 shadow-sm'>
          <div className='flex items-center justify-between'>
            <h2 className='text-lg font-medium'>
              {manualEntry ? 'Enter Barcode Manually' : 'Scan Applicator Barcode'}
            </h2>
            <button
              onClick={toggleEntryMode}
              className='text-sm font-medium text-primary hover:text-primary/80'>
              {manualEntry ? 'Switch to Scanner' : 'Enter Manually'}
            </button>
          </div>

          {error && (
            <div className='mt-4 rounded-md bg-red-50 p-4 text-sm text-red-700'>{error}</div>
          )}

          {manualEntry ? (
            <form onSubmit={handleManualSubmit} className='mt-4 space-y-4'>
              <div>
                <label htmlFor='barcode' className='block text-sm font-medium text-gray-700'>
                  Barcode
                </label>
                <input
                  type='text'
                  id='barcode'
                  value={barcodeValue}
                  onChange={(e) => setBarcodeValue(e.target.value)}
                  className='mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm'
                  placeholder='Enter barcode number'
                  autoFocus
                />
              </div>
              <div className='flex justify-end'>
                <button
                  type='submit'
                  disabled={loading || !barcodeValue}
                  className='rounded-md bg-primary px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 disabled:opacity-50'>
                  {loading ? 'Processing...' : 'Submit'}
                </button>
              </div>
            </form>
          ) : (
            <div className='mt-4'>
              <div id='qr-reader' ref={scannerDivRef} className='mx-auto max-w-sm'></div>
              <p className='mt-4 text-center text-sm text-gray-500'>
                Position the barcode inside the scan area
              </p>
            </div>
          )}
        </div>
      </div>
    </Layout>
  );
};

export default ScanQRCode;

================
File: frontend/src/pages/Treatment/SeedRemoval.tsx
================
import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import Layout from '@/components/Layout';
import { useTreatment } from '@/context/TreatmentContext';
import { treatmentService, Applicator } from '@/services/treatmentService';

const SeedRemoval = () => {
  const navigate = useNavigate();
  const { currentTreatment, applicators, updateApplicator, totalSeeds, removedSeeds } =
    useTreatment();

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isCompleting, setIsCompleting] = useState(false);

  useEffect(() => {
    if (!currentTreatment) {
      navigate('/treatment/select');
      return;
    }

    if (currentTreatment.type !== 'removal') {
      navigate('/treatment/select');
      return;
    }

    // If no applicators in state, fetch them from the server
    if (applicators.length === 0) {
      fetchApplicators();
    }
  }, [currentTreatment, applicators.length]);

  const fetchApplicators = async () => {
    if (!currentTreatment) return;

    setLoading(true);
    setError(null);

    try {
      const data = await treatmentService.getApplicators(currentTreatment.id);
      // This would normally update the state in the TreatmentContext
      // But for demo purposes, we're just logging
      console.log('Fetched applicators:', data);
    } catch (err: any) {
      setError(err.message || 'Failed to fetch applicators');
    } finally {
      setLoading(false);
    }
  };

  const handleToggleRemoval = async (applicator: Applicator) => {
    if (!currentTreatment) return;

    try {
      const updatedApplicator = {
        ...applicator,
        isRemoved: !applicator.isRemoved,
        removalTime: !applicator.isRemoved ? new Date().toISOString() : null,
      };

      // Update in backend
      await treatmentService.updateApplicator(
        currentTreatment.id,
        applicator.id,
        updatedApplicator
      );

      // Update in state
      updateApplicator(applicator.id, updatedApplicator);
    } catch (err: any) {
      setError(err.message || 'Failed to update applicator');
    }
  };

  const handleAddComment = async (applicator: Applicator, comment: string) => {
    if (!currentTreatment) return;

    try {
      const updatedApplicator = {
        ...applicator,
        removalComments: comment,
      };

      // Update in backend
      await treatmentService.updateApplicator(
        currentTreatment.id,
        applicator.id,
        updatedApplicator
      );

      // Update in state
      updateApplicator(applicator.id, updatedApplicator);
    } catch (err: any) {
      setError(err.message || 'Failed to update comment');
    }
  };

  const handleCommentChange = (
    applicator: Applicator,
    e: React.ChangeEvent<HTMLTextAreaElement>
  ) => {
    const updatedApplicator = {
      ...applicator,
      removalComments: e.target.value,
    };

    // Just update in state for now (will be saved on blur or form submit)
    updateApplicator(applicator.id, updatedApplicator);
  };

  const handleCompleteTreatment = async () => {
    if (!currentTreatment) return;

    setIsCompleting(true);

    try {
      await treatmentService.completeTreatment(currentTreatment.id);
      navigate('/treatment/select');
    } catch (err: any) {
      setError(err.message || 'Failed to complete treatment');
    } finally {
      setIsCompleting(false);
    }
  };

  if (!currentTreatment) {
    return (
      <Layout title='Seed Removal' showBackButton>
        <div className='flex items-center justify-center py-10'>
          <p>No treatment selected. Please select a treatment first.</p>
        </div>
      </Layout>
    );
  }

  return (
    <Layout title='Seed Removal' showBackButton backPath='/treatment/select'>
      <div className='space-y-6'>
        <div className='rounded-lg border bg-white p-4 shadow-sm'>
          <h2 className='mb-4 text-lg font-medium'>Treatment Information</h2>
          <div className='grid grid-cols-2 gap-4 md:grid-cols-4'>
            <div>
              <p className='text-sm text-gray-500'>Subject ID</p>
              <p className='font-medium'>{currentTreatment.subjectId}</p>
            </div>
            <div>
              <p className='text-sm text-gray-500'>Site</p>
              <p className='font-medium'>{currentTreatment.site}</p>
            </div>
            <div>
              <p className='text-sm text-gray-500'>Type</p>
              <p className='font-medium capitalize'>{currentTreatment.type}</p>
            </div>
            <div>
              <p className='text-sm text-gray-500'>Date</p>
              <p className='font-medium'>{new Date(currentTreatment.date).toLocaleDateString()}</p>
            </div>
          </div>
        </div>

        {error && <div className='rounded-md bg-red-50 p-4 text-sm text-red-700'>{error}</div>}

        <div className='rounded-lg border bg-white p-4 shadow-sm'>
          <div className='mb-4 flex items-center justify-between'>
            <h2 className='text-lg font-medium'>Seed Removal Tracking</h2>
            <div className='flex items-center space-x-2'>
              <div className='rounded-md bg-blue-50 px-3 py-1 text-sm font-medium text-blue-700'>
                Seeds: {removedSeeds} / {totalSeeds}
              </div>
            </div>
          </div>

          {loading ? (
            <div className='flex justify-center py-8'>
              <div className='h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent'></div>
            </div>
          ) : applicators.length === 0 ? (
            <div className='rounded-md bg-yellow-50 p-4 text-sm text-yellow-700'>
              No applicators found for this treatment.
            </div>
          ) : (
            <div className='space-y-4'>
              {applicators.map((applicator) => (
                <div
                  key={applicator.id}
                  className={`rounded-lg border p-4 ${
                    applicator.isRemoved
                      ? 'border-green-200 bg-green-50'
                      : 'border-gray-200 bg-white'
                  }`}>
                  <div className='flex flex-col space-y-4 md:flex-row md:items-center md:justify-between md:space-y-0'>
                    <div>
                      <h3 className='text-md font-medium'>{applicator.serialNumber}</h3>
                      <p className='text-sm text-gray-500'>
                        Seeds: {applicator.seedQuantity} | Usage:{' '}
                        {applicator.usageType === 'full'
                          ? 'Full Use'
                          : applicator.usageType === 'faulty'
                            ? 'Faulty'
                            : 'No Use'}
                      </p>
                    </div>

                    <div className='flex items-center space-x-4'>
                      <div className='flex items-center'>
                        <input
                          id={`isRemoved-${applicator.id}`}
                          type='checkbox'
                          checked={applicator.isRemoved}
                          onChange={() => handleToggleRemoval(applicator)}
                          className='h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary'
                        />
                        <label
                          htmlFor={`isRemoved-${applicator.id}`}
                          className='ml-2 text-sm font-medium text-gray-700'>
                          {applicator.isRemoved ? 'Removed' : 'Mark as Removed'}
                        </label>
                      </div>
                    </div>
                  </div>

                  <div className='mt-4'>
                    <label
                      htmlFor={`comments-${applicator.id}`}
                      className='block text-sm font-medium text-gray-700'>
                      Removal Comments
                    </label>
                    <textarea
                      id={`comments-${applicator.id}`}
                      value={applicator.removalComments || ''}
                      onChange={(e) => handleCommentChange(applicator, e)}
                      onBlur={() =>
                        applicator.removalComments &&
                        handleAddComment(applicator, applicator.removalComments)
                      }
                      rows={2}
                      className='mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm'
                      placeholder='Add removal comments...'></textarea>
                  </div>
                </div>
              ))}
            </div>
          )}

          <div className='mt-6 flex items-center justify-between'>
            <div
              className={`text-lg font-medium ${
                removedSeeds === totalSeeds ? 'text-green-600' : 'text-red-600'
              }`}>
              Total: {removedSeeds} / {totalSeeds} Seeds Removed
            </div>
            <button
              onClick={handleCompleteTreatment}
              disabled={isCompleting || loading}
              className='rounded-md bg-primary px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 disabled:opacity-50'>
              {isCompleting
                ? 'Completing...'
                : removedSeeds === totalSeeds
                  ? 'Complete Treatment'
                  : 'Complete with Missing Seeds'}
            </button>
          </div>
        </div>
      </div>
    </Layout>
  );
};

export default SeedRemoval;

================
File: frontend/src/pages/Treatment/TreatmentSelection.tsx
================
import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { format } from 'date-fns';
import Layout from '@/components/Layout';
import { useTreatment } from '@/context/TreatmentContext';
import { treatmentService, Treatment } from '@/services/treatmentService';

const TreatmentSelection = () => {
  const { setTreatment } = useTreatment();
  const navigate = useNavigate();

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [treatments, setTreatments] = useState<Treatment[]>([]);

  const [treatmentType, setTreatmentType] = useState<'insertion' | 'removal'>('insertion');
  const [searchParams, setSearchParams] = useState({
    subjectId: '',
    site: '',
    date: format(new Date(), 'yyyy-MM-dd'),
  });

  useEffect(() => {
    fetchTreatments();
  }, [treatmentType]);

  const fetchTreatments = async () => {
    setLoading(true);
    setError(null);

    try {
      // Filter parameters
      const params = {
        type: treatmentType,
        ...searchParams,
      };

      // Only include non-empty params
      const filteredParams = Object.entries(params).reduce(
        (acc, [key, value]) => {
          if (value) {
            if (key === 'type') {
              acc[key] = value as 'insertion' | 'removal';
            } else {
              acc[key] = value;
            }
          }
          return acc;
        },
        {} as Record<string, any>
      );

      const data = await treatmentService.getTreatments(filteredParams);
      setTreatments(data);
    } catch (err: any) {
      setError(err.message || 'Failed to fetch treatments');
    } finally {
      setLoading(false);
    }
  };

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    fetchTreatments();
  };

  const handleDateChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const date = e.target.value;
    setSearchParams({ ...searchParams, date });
  };

  const handleSelectTreatment = (treatment: Treatment) => {
    setTreatment(treatment);
    if (treatment.type === 'insertion') {
      navigate('/treatment/scan');
    } else {
      navigate('/treatment/removal');
    }
  };

  return (
    <Layout title='Treatment Selection'>
      <div className='space-y-6'>
        <div className='rounded-lg border bg-white p-4 shadow-sm'>
          <h2 className='mb-4 text-lg font-medium'>Select Treatment Type</h2>
          <div className='flex space-x-4'>
            <button
              onClick={() => setTreatmentType('insertion')}
              className={`flex-1 rounded-md px-4 py-2 ${
                treatmentType === 'insertion'
                  ? 'bg-primary text-white'
                  : 'bg-gray-100 text-gray-800 hover:bg-gray-200'
              }`}>
              Insertion
            </button>
            <button
              onClick={() => setTreatmentType('removal')}
              className={`flex-1 rounded-md px-4 py-2 ${
                treatmentType === 'removal'
                  ? 'bg-primary text-white'
                  : 'bg-gray-100 text-gray-800 hover:bg-gray-200'
              }`}>
              Removal
            </button>
          </div>
        </div>

        <div className='rounded-lg border bg-white p-4 shadow-sm'>
          <h2 className='mb-4 text-lg font-medium'>Search Treatments</h2>
          <form onSubmit={handleSearch} className='space-y-4'>
            <div className='grid grid-cols-1 gap-4 md:grid-cols-3'>
              <div>
                <label htmlFor='subjectId' className='block text-sm font-medium text-gray-700'>
                  Subject ID
                </label>
                <input
                  type='text'
                  id='subjectId'
                  value={searchParams.subjectId}
                  onChange={(e) => setSearchParams({ ...searchParams, subjectId: e.target.value })}
                  className='mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm'
                />
              </div>
              <div>
                <label htmlFor='site' className='block text-sm font-medium text-gray-700'>
                  Treatment Site
                </label>
                <input
                  type='text'
                  id='site'
                  value={searchParams.site}
                  onChange={(e) => setSearchParams({ ...searchParams, site: e.target.value })}
                  className='mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm'
                />
              </div>
              <div>
                <label htmlFor='date' className='block text-sm font-medium text-gray-700'>
                  Date
                </label>
                <input
                  type='date'
                  id='date'
                  value={searchParams.date}
                  onChange={handleDateChange}
                  className='mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm'
                />
              </div>
            </div>
            <div className='flex justify-end'>
              <button
                type='submit'
                className='rounded-md bg-primary px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2'>
                Search
              </button>
            </div>
          </form>
        </div>

        <div className='rounded-lg border bg-white p-4 shadow-sm'>
          <h2 className='mb-4 text-lg font-medium'>Available Treatments</h2>

          {loading ? (
            <div className='flex justify-center py-8'>
              <div className='h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent'></div>
            </div>
          ) : error ? (
            <div className='rounded-md bg-red-50 p-4 text-sm text-red-700'>{error}</div>
          ) : treatments.length === 0 ? (
            <div className='rounded-md bg-blue-50 p-4 text-sm text-blue-700'>
              No treatments found. Try adjusting your search criteria.
            </div>
          ) : (
            <div className='overflow-hidden rounded-lg border'>
              <table className='min-w-full divide-y divide-gray-200'>
                <thead className='bg-gray-50'>
                  <tr>
                    <th
                      scope='col'
                      className='px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500'>
                      Subject ID
                    </th>
                    <th
                      scope='col'
                      className='px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500'>
                      Site
                    </th>
                    <th
                      scope='col'
                      className='px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500'>
                      Date
                    </th>
                    <th
                      scope='col'
                      className='px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500'>
                      Type
                    </th>
                    <th
                      scope='col'
                      className='px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500'>
                      Action
                    </th>
                  </tr>
                </thead>
                <tbody className='divide-y divide-gray-200 bg-white'>
                  {treatments.map((treatment) => (
                    <tr key={treatment.id} className='hover:bg-gray-50'>
                      <td className='whitespace-nowrap px-6 py-4 text-sm font-medium text-gray-900'>
                        {treatment.subjectId}
                      </td>
                      <td className='whitespace-nowrap px-6 py-4 text-sm text-gray-500'>
                        {treatment.site}
                      </td>
                      <td className='whitespace-nowrap px-6 py-4 text-sm text-gray-500'>
                        {format(new Date(treatment.date), 'MMM d, yyyy')}
                      </td>
                      <td className='whitespace-nowrap px-6 py-4 text-sm text-gray-500'>
                        <span
                          className={`inline-flex rounded-full px-2 text-xs font-semibold leading-5 ${
                            treatment.type === 'insertion'
                              ? 'bg-green-100 text-green-800'
                              : 'bg-blue-100 text-blue-800'
                          }`}>
                          {treatment.type === 'insertion' ? 'Insertion' : 'Removal'}
                        </span>
                      </td>
                      <td className='whitespace-nowrap px-6 py-4 text-right text-sm font-medium'>
                        <button
                          onClick={() => handleSelectTreatment(treatment)}
                          className='text-primary hover:text-primary/80'>
                          Select
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </div>
    </Layout>
  );
};

export default TreatmentSelection;

================
File: frontend/src/pages/Treatment/UseList.tsx
================
import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { format } from 'date-fns';
import Layout from '@/components/Layout';
import { useTreatment } from '@/context/TreatmentContext';
import { treatmentService, Applicator } from '@/services/treatmentService';

const UseList = () => {
  const navigate = useNavigate();
  const { currentTreatment, applicators, setCurrentApplicator } = useTreatment();
  
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [exportType, setExportType] = useState<'csv' | 'pdf'>('csv');
  const [isExporting, setIsExporting] = useState(false);
  
  useEffect(() => {
    if (!currentTreatment) {
      navigate('/treatment/select');
      return;
    }
    
    // If no applicators in state, fetch them from the server
    if (applicators.length === 0) {
      fetchApplicators();
    }
  }, [currentTreatment, applicators.length]);

  const fetchApplicators = async () => {
    if (!currentTreatment) return;
    
    setLoading(true);
    setError(null);
    
    try {
      const data = await treatmentService.getApplicators(currentTreatment.id);
      // This would normally update the state in the TreatmentContext
      // But for demo purposes, we're just logging
      console.log('Fetched applicators:', data);
    } catch (err: any) {
      setError(err.message || 'Failed to fetch applicators');
    } finally {
      setLoading(false);
    }
  };

  const handleEditApplicator = (applicator: Applicator) => {
    setCurrentApplicator(applicator);
    navigate('/treatment/applicator');
  };

  const handleExport = async () => {
    if (!currentTreatment) return;
    
    setIsExporting(true);
    
    try {
      const blob = await treatmentService.exportTreatment(currentTreatment.id, exportType);
      
      // Create download link
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = `treatment-${currentTreatment.id}.${exportType}`;
      document.body.appendChild(a);
      a.click();
      
      // Clean up
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    } catch (err: any) {
      setError(err.message || `Failed to export as ${exportType.toUpperCase()}`);
    } finally {
      setIsExporting(false);
    }
  };

  const handleScanMore = () => {
    navigate('/treatment/scan');
  };

  const handleComplete = async () => {
    if (!currentTreatment) return;
    
    setLoading(true);
    
    try {
      await treatmentService.completeTreatment(currentTreatment.id);
      navigate('/treatment/select');
    } catch (err: any) {
      setError(err.message || 'Failed to complete treatment');
    } finally {
      setLoading(false);
    }
  };

  if (!currentTreatment) {
    return (
      <Layout title="Use List" showBackButton>
        <div className="flex items-center justify-center py-10">
          <p>No treatment selected. Please select a treatment first.</p>
        </div>
      </Layout>
    );
  }

  return (
    <Layout title="Use List" showBackButton backPath="/treatment/select">
      <div className="space-y-6">
        <div className="rounded-lg border bg-white p-4 shadow-sm">
          <h2 className="mb-4 text-lg font-medium">Treatment Information</h2>
          <div className="grid grid-cols-2 gap-4 md:grid-cols-4">
            <div>
              <p className="text-sm text-gray-500">Subject ID</p>
              <p className="font-medium">{currentTreatment.subjectId}</p>
            </div>
            <div>
              <p className="text-sm text-gray-500">Site</p>
              <p className="font-medium">{currentTreatment.site}</p>
            </div>
            <div>
              <p className="text-sm text-gray-500">Type</p>
              <p className="font-medium capitalize">{currentTreatment.type}</p>
            </div>
            <div>
              <p className="text-sm text-gray-500">Date</p>
              <p className="font-medium">{new Date(currentTreatment.date).toLocaleDateString()}</p>
            </div>
          </div>
        </div>

        {error && (
          <div className="rounded-md bg-red-50 p-4 text-sm text-red-700">
            {error}
          </div>
        )}

        <div className="rounded-lg border bg-white p-4 shadow-sm">
          <div className="mb-4 flex items-center justify-between">
            <h2 className="text-lg font-medium">Applicators</h2>
            <div className="flex items-center space-x-2">
              <select
                value={exportType}
                onChange={(e) => setExportType(e.target.value as 'csv' | 'pdf')}
                className="rounded-md border border-gray-300 px-3 py-1 text-sm focus:border-primary focus:outline-none focus:ring-primary"
              >
                <option value="csv">CSV</option>
                <option value="pdf">PDF</option>
              </select>
              <button
                onClick={handleExport}
                disabled={isExporting || applicators.length === 0}
                className="rounded-md bg-secondary px-3 py-1 text-sm font-medium text-secondary-foreground hover:bg-secondary/90 focus:outline-none focus:ring-2 focus:ring-secondary focus:ring-offset-2 disabled:opacity-50"
              >
                {isExporting ? 'Exporting...' : 'Export'}
              </button>
            </div>
          </div>

          {loading ? (
            <div className="flex justify-center py-8">
              <div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent"></div>
            </div>
          ) : applicators.length === 0 ? (
            <div className="rounded-md bg-blue-50 p-4 text-sm text-blue-700">
              No applicators added yet. Start by scanning an applicator.
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                      Serial Number
                    </th>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                      Seed Quantity
                    </th>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                      Usage Type
                    </th>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                      Insertion Time
                    </th>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                      Comments
                    </th>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500">
                      Action
                    </th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-gray-200 bg-white">
                  {applicators.map((applicator) => (
                    <tr key={applicator.id || applicator.serialNumber} className="hover:bg-gray-50">
                      <td className="whitespace-nowrap px-6 py-4 text-sm font-medium text-gray-900">
                        {applicator.serialNumber}
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                        {applicator.seedQuantity}
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm">
                        <span className={`inline-flex rounded-full px-2 text-xs font-semibold leading-5 ${
                          applicator.usageType === 'full'
                            ? 'bg-green-100 text-green-800'
                            : applicator.usageType === 'faulty'
                            ? 'bg-red-100 text-red-800'
                            : 'bg-gray-100 text-gray-800'
                        }`}>
                          {applicator.usageType === 'full'
                            ? 'Full Use'
                            : applicator.usageType === 'faulty'
                            ? 'Faulty'
                            : 'No Use'
                          }
                        </span>
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-sm text-gray-500">
                        {format(new Date(applicator.insertionTime), 'MMM d, yyyy HH:mm')}
                      </td>
                      <td className="px-6 py-4 text-sm text-gray-500">
                        {applicator.comments ? (
                          <span className="line-clamp-1">{applicator.comments}</span>
                        ) : (
                          <span className="text-gray-400">No comments</span>
                        )}
                      </td>
                      <td className="whitespace-nowrap px-6 py-4 text-right text-sm font-medium">
                        <button
                          onClick={() => handleEditApplicator(applicator)}
                          className="text-primary hover:text-primary/80"
                        >
                          Edit
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          <div className="mt-6 flex justify-between">
            <button
              onClick={handleScanMore}
              className="rounded-md border border-primary bg-white px-4 py-2 text-sm font-medium text-primary shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2"
            >
              Scan More Applicators
            </button>
            <button
              onClick={handleComplete}
              disabled={loading || applicators.length === 0}
              className="rounded-md bg-primary px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 disabled:opacity-50"
            >
              {loading ? 'Processing...' : 'Complete Treatment'}
            </button>
          </div>
        </div>
      </div>
    </Layout>
  );
};

export default UseList;

================
File: frontend/src/services/api.ts
================
import axios from 'axios';

const baseURL = (import.meta as any).env.VITE_API_URL || 'http://localhost:5000/api';

const api = axios.create({
  baseURL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor to include auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Add response interceptor for error handling
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // Handle offline mode
    if (!navigator.onLine) {
      throw new Error('You are currently offline. Please check your connection.');
    }

    // Handle authentication errors
    if (error.response?.status === 401 && !originalRequest._retry) {
      // Clear invalid auth data
      localStorage.removeItem('token');
      localStorage.removeItem('user');
      window.location.href = '/login';
    }

    return Promise.reject(error);
  }
);

export default api;

================
File: frontend/src/services/treatmentService.ts
================
import api from './api';
import { priorityService } from './priorityService';

export interface Treatment {
  id: string;
  type: 'insertion' | 'removal';
  subjectId: string;
  site: string;
  date: string;
  isComplete: boolean;
}

export interface Applicator {
  id: string;
  serialNumber: string;
  seedQuantity: number;
  usageType: 'full' | 'faulty' | 'none';
  insertionTime: string;
  comments?: string;
  image?: string;
  isRemoved?: boolean;
  removalComments?: string;
  removalImage?: string;
}

export const treatmentService = {
  // Get available treatments for selection
  async getTreatments(params: {
    type?: 'insertion' | 'removal';
    subjectId?: string;
    site?: string;
    date?: string;
  }): Promise<Treatment[]> {
    try {
      // First try to get from backend
      const response = await api.get('/treatments', { params });
      return response.data;
    } catch (error) {
      // If offline or backend fails, try to get from Priority directly
      if (navigator.onLine) {
        return await priorityService.getTreatments(params);
      }
      
      // If offline, get from local storage
      const cachedTreatments = localStorage.getItem('cached_treatments');
      if (cachedTreatments) {
        const treatments = JSON.parse(cachedTreatments) as Treatment[];
        
        // Apply filters if any
        return treatments.filter(treatment => {
          let include = true;
          if (params.type && treatment.type !== params.type) include = false;
          if (params.subjectId && treatment.subjectId !== params.subjectId) include = false;
          if (params.site && treatment.site !== params.site) include = false;
          if (params.date && treatment.date.slice(0, 10) !== params.date) include = false;
          return include;
        });
      }
      
      return [];
    }
  },

  // Get details for a specific treatment
  async getTreatment(id: string): Promise<Treatment> {
    const response = await api.get(`/treatments/${id}`);
    return response.data;
  },

  // Get applicators for a treatment
  async getApplicators(treatmentId: string): Promise<Applicator[]> {
    const response = await api.get(`/treatments/${treatmentId}/applicators`);
    return response.data;
  },

  // Validate applicator barcode
  async validateApplicator(barcode: string, treatmentId: string): Promise<{
    valid: boolean;
    message: string;
    requiresAdminApproval: boolean;
    applicator?: Applicator;
  }> {
    const response = await api.post(`/applicators/validate`, {
      barcode,
      treatmentId,
    });
    return response.data;
  },

  // Add an applicator to a treatment
  async addApplicator(treatmentId: string, applicator: Omit<Applicator, 'id'>): Promise<Applicator> {
    const response = await api.post(`/treatments/${treatmentId}/applicators`, applicator);
    return response.data;
  },

  // Update an applicator
  async updateApplicator(treatmentId: string, applicatorId: string, data: Partial<Applicator>): Promise<Applicator> {
    const response = await api.patch(`/treatments/${treatmentId}/applicators/${applicatorId}`, data);
    return response.data;
  },

  // Complete a treatment
  async completeTreatment(treatmentId: string): Promise<Treatment> {
    const response = await api.post(`/treatments/${treatmentId}/complete`);
    return response.data;
  },

  // Export treatment data as CSV or PDF
  async exportTreatment(treatmentId: string, format: 'csv' | 'pdf'): Promise<Blob> {
    const response = await api.get(`/treatments/${treatmentId}/export`, {
      params: { format },
      responseType: 'blob'
    });
    return response.data;
  }
};

================
File: frontend/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: 0 },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: 0 },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}

================
File: frontend/tsconfig.node.json
================
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: GITHUB-README.md
================
# Accountability Log Application (ALA)

A comprehensive application for tracking medical treatments, applicator usage, and seed management with a focus on reliability and user experience.

##  Project Structure

```
ala-improved/
 .env.docker
 .gitignore
 azure/
    azure-deploy.sh
    deploy.ps1
    README.md
 backend/
    Dockerfile
    package.json
    src/
       config/
          database.ts
       controllers/
          authController.ts
       middleware/
          authMiddleware.ts
          errorMiddleware.ts
          notFoundMiddleware.ts
       models/
          Applicator.ts
          index.ts
          Treatment.ts
          User.ts
       routes/
          adminRoutes.ts
          applicatorRoutes.ts
          authRoutes.ts
          treatmentRoutes.ts
       utils/
          logger.ts
       seedUser.js
       seedUser.ts
       server.ts
    tsconfig.json
 debug.bat
 debug.sh
 docker-compose.dev.yml
 docker-compose.prod.yml
 docker-compose.yml
 docs/
    IMPROVEMENTS.md
 frontend/
    Dockerfile
    Dockerfile.dev
    index.html
    nginx.conf
    package.json
    postcss.config.js
    src/
       App.tsx
       components/
          FileExplorer.tsx
          Layout.tsx
          ProtectedRoute.tsx
       context/
          AuthContext.tsx
          TreatmentContext.tsx
       index.css
       main.tsx
       pages/
          Admin/
             Dashboard.tsx
          Auth/
             LoginPage.tsx
             VerificationPage.tsx
          Treatment/
             ApplicatorInformation.tsx
             ScanQRCode.tsx
             SeedRemoval.tsx
             TreatmentSelection.tsx
             UseList.tsx
          ProjectDocPage.tsx
       services/
           api.ts
           authService.ts
           priorityService.ts
           treatmentService.ts
    tailwind.config.js
    tsconfig.json
    tsconfig.node.json
    vite.config.ts
 README.md
 restart.bat
 scripts/
     debug.js
```

##  Features

- **Secure Authentication**: Verification code-based login via SMS/email
- **Treatment Management**: Track and document medical treatments
- **Barcode Scanning**: Scan applicator barcodes with validation
- **Offline Support**: Continue working without network connectivity
- **Reporting**: Generate treatment reports in CSV/PDF formats
- **Admin Dashboard**: Monitor system usage and manage configurations
- **Priority Integration**: Seamless connection to the Priority system

##  Technology Stack

### Backend
- Node.js with Express
- TypeScript
- Sequelize ORM
- PostgreSQL
- JWT authentication
- Winston for logging

### Frontend
- React 18
- TypeScript
- Tailwind CSS
- Vite
- Context API for state management
- React Router for navigation

### DevOps
- Docker & Docker Compose
- Azure Container Registry
- Azure App Service
- Azure Database for PostgreSQL

##  Getting Started

### Development Mode

```bash
# Clone the repository
git clone https://github.com/AT2024/ALA.git
cd ALA

# Start the development environment
docker-compose -f docker-compose.dev.yml up -d

# Access the application
# Frontend: http://localhost:3000
# Backend API: http://localhost:5000
# Documentation: http://localhost:3000/docs
```

### Production Mode

```bash
# Start the production environment
docker-compose -f docker-compose.prod.yml up -d
```

### Debugging

```bash
# Run the debug script
./debug.bat  # Windows
./debug.sh   # Linux/Mac

# Restart containers
./restart.bat
```

##  Recent Updates

- Fixed API path inconsistencies in authentication service
- Enhanced Priority system integration
- Added comprehensive debugging tools
- Improved error handling and TypeScript type safety
- Added project documentation with visual file explorer

##  Integration with Priority

The application integrates with the Priority system using the following endpoints:
- `/PHONEBOOK` - For contact information
- `/ORDERS` - For treatment data

Position code '99' grants access to all treatment sites, while other codes restrict users to their assigned sites.

##  Debugging Tools

The application includes several debugging utilities:
- `debug.bat`/`debug.sh` - Test connectivity to backend and Priority APIs
- `scripts/debug.js` - Detailed diagnostic script
- `restart.bat` - Restart Docker containers
- Project documentation page at `/docs`

##  Documentation

Access the built-in documentation by navigating to `/docs` in the running application. The documentation includes:
- File structure visualization
- Recent changes
- Running instructions
- Debugging tips

##  License

Proprietary - All rights reserved

================
File: memory-bank/activeContext.md
================
# Active Context

## Current Session
Started: 2025-05-15 17:11:28
Mode: Development
Current Task: Initial Setup

## Tasks
### In Progress
- [ ] Project initialization
- [ ] Environment setup

## Open Questions
- What are the primary project goals?
- What are the key technical requirements?

## Recent Updates
- 2025-05-15: Project initialized

## Session Update (2025-05-15)
- Mode: maintenance
- Task: Fix Priority integration in ALA application

================
File: memory-bank/decisionLog.md
================
# Decision Log

## Technical Decisions

### Initial Project Structure (2025-05-15)
Initialized Unknown with a modular architecture using Node.js

**Status:** accepted
**Impact:** Project-wide

Rationale:
Established foundation for scalable and maintainable development




### Development Workflow (2025-05-15)
Established initial development workflow and practices

**Status:** accepted
**Impact:** Development process

Rationale:
Ensure consistent development process and code quality

Alternatives Considered:
- Ad-hoc development process
- Waterfall methodology



### Documentation Strategy (2025-05-15)
Implemented automated documentation with memory bank

**Status:** accepted
**Impact:** Project documentation

Rationale:
Maintain up-to-date project context and decision history

### Implement Priority API integration through backend proxy (2025-05-15)
Implement a comprehensive backend proxy for all Priority API calls to avoid direct frontend calls to Priority

**Status:** accepted
**Impact:** This change affects the authentication flow, treatment retrieval, and all other Priority-related functionality across the application. The primary benefits include improved security, better error handling, and a more consistent user experience.

Rationale:
Direct frontend-to-Priority API calls were causing multiple issues including CORS problems, security concerns with exposing credentials, and general integration difficulties. By moving all Priority API calls through our backend, we provide a secure, consistent interface that handles authentication, error handling, and data formatting.

Alternatives Considered:
- Continue with direct frontend-to-Priority API calls with CORS workarounds
- Create a separate microservice for Priority integration
- Use mock data instead of real Priority integration

## Pending Decisions

================
File: memory-bank/progress.md
================
# Progress Log

## Current Phase
Initialization

## Completed Tasks
- Repository setup (2025-05-15)
- Basic project structure (2025-05-15)

## In Progress
- Development environment configuration
- Initial documentation

## Upcoming
- Code implementation
- Testing setup

## Blockers
[None currently identified]

## Update (2025-05-15)
Phase: Development
Questions Processed: 4

Completed:
-  Analyze existing Priority integration code
-  Identify issues with Priority API connection
-  Implement backend proxy services for Priority API
-  Update frontend services to use backend proxy
-  Fix authentication flow to work with Priority API

In Progress:
-  Testing Priority API integration

Blocked:

================
File: memory-bank/projectContext.md
================
# Project Context

## Overview
Unknown - No description provided
Version: 0.1.0
License: Not specified

## Technical Stack
Runtime: Node.js
Languages: JavaScript, PHP, Python, TypeScript, TypeScript (React)


## Dependencies
Core:
None

Development:
None

## Configuration
- .babelrc
- .env
- .eslintrc
- .gitignore
- package.json
- rollup.config.js
- tsconfig.json
- vite.config.js
- webpack.config.js

## Architecture
- Type: Modular
- Language: JavaScript
- Environment: Node.js

================
File: scripts/debug.js
================
/**
 * Debug script for ALA Application
 * Run with: node scripts/debug.js
 */

const axios = require('axios');
const fs = require('fs');
const path = require('path');
const util = require('util');

// Configuration
const config = {
  backendUrl: 'http://localhost:5000',
  priorityUrl: 'https://t.eu.priority-connect.online/odata/Priority/tabbtbc6.ini/test24/',
  testCredentials: {
    identifier: 'test@example.com',
    code: '123456'
  }
};

// Set up logging
const logFile = path.join(__dirname, '..', 'logs', 'debug.log');
const logDir = path.dirname(logFile);

// Ensure logs directory exists
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir, { recursive: true });
}

// Create write stream for log file
const log = fs.createWriteStream(logFile, { flags: 'a' });

// Log function that writes to console and file
function logMessage(message, data = null) {
  const timestamp = new Date().toISOString();
  const logEntry = `[${timestamp}] ${message}`;
  
  console.log(logEntry);
  log.write(logEntry + '\n');
  
  if (data) {
    const formatted = typeof data === 'string' ? data : util.inspect(data, { depth: null, colors: false });
    console.log(formatted);
    log.write(formatted + '\n');
  }
}

// Test backend connectivity
async function testBackendConnectivity() {
  try {
    logMessage('Testing backend connectivity...');
    const response = await axios.get(`${config.backendUrl}/api/health`);
    logMessage('Backend health check successful', response.data);
    return true;
  } catch (error) {
    logMessage('Backend health check failed', error.message);
    if (error.response) {
      logMessage('Error response', {
        status: error.response.status,
        data: error.response.data
      });
    }
    return false;
  }
}

// Test backend routes
async function testBackendRoutes() {
  try {
    logMessage('Testing backend API routes...');
    const response = await axios.get(`${config.backendUrl}/api/routes`);
    logMessage('Backend routes check successful', response.data);
    return response.data;
  } catch (error) {
    logMessage('Backend routes check failed', error.message);
    return null;
  }
}

// Test auth endpoints
async function testAuthEndpoints() {
  try {
    logMessage('Testing auth request-code endpoint...');
    const response = await axios.post(`${config.backendUrl}/api/auth/request-code`, {
      identifier: config.testCredentials.identifier
    });
    logMessage('Auth request-code successful', response.data);
    return true;
  } catch (error) {
    logMessage('Auth request-code failed', error.message);
    if (error.response) {
      logMessage('Error response', {
        status: error.response.status,
        data: error.response.data
      });
    }
    return false;
  }
}

// Test Priority API connectivity
async function testPriorityConnectivity() {
  try {
    logMessage('Testing Priority API connectivity...');
    logMessage(`Using Priority URL: ${config.priorityUrl}`);
    
    // Test PHONEBOOK endpoint
    const phonebookResponse = await axios.get(`${config.priorityUrl}PHONEBOOK`, {
      timeout: 10000
    });
    
    logMessage('Priority PHONEBOOK endpoint successful', {
      count: phonebookResponse.data.value.length,
      sample: phonebookResponse.data.value.length > 0 ? phonebookResponse.data.value[0] : null
    });
    
    // Test ORDERS endpoint
    const ordersResponse = await axios.get(`${config.priorityUrl}ORDERS?$filter=CUSTNAME eq '100078'`, {
      timeout: 10000
    });
    
    logMessage('Priority ORDERS endpoint successful', {
      count: ordersResponse.data.value.length,
      sample: ordersResponse.data.value.length > 0 ? ordersResponse.data.value[0] : null
    });
    
    return true;
  } catch (error) {
    logMessage('Priority API connectivity test failed', error.message);
    if (error.response) {
      logMessage('Error response', {
        status: error.response.status,
        data: error.response.data
      });
    }
    return false;
  }
}

// Run all tests
async function runTests() {
  logMessage('===== Starting ALA Application Debug =====');
  
  // Test backend connectivity
  const backendConnected = await testBackendConnectivity();
  
  // Only proceed with other tests if backend is connected
  if (backendConnected) {
    await testBackendRoutes();
    await testAuthEndpoints();
  }
  
  // Test Priority API
  await testPriorityConnectivity();
  
  logMessage('===== ALA Application Debug Complete =====');
  log.end();
}

// Run the tests
runTests().catch(error => {
  logMessage('Error running tests', error);
  log.end();
});

================
File: scripts/new-feature.bat
================
@echo off
REM Script to create a new feature branch from develop
REM Usage: new-feature.bat feature-name

if "%~1"=="" (
  echo Error: You must provide a feature name!
  echo Usage: new-feature.bat feature-name
  exit /b 1
)

set FEATURE_NAME=%~1

REM Make sure we're on the develop branch first
git checkout develop

REM Pull the latest changes from develop
git pull origin develop

REM Create and switch to the new feature branch
git checkout -b "feature/%FEATURE_NAME%"

echo Created and switched to branch 'feature/%FEATURE_NAME%'
echo Make your changes and then use: git add . ^&^& git commit -m "Description"
echo When ready, push with: git push -u origin feature/%FEATURE_NAME%
echo Then create a pull request from feature/%FEATURE_NAME% to develop

================
File: scripts/new-feature.sh
================
#!/bin/bash
# Script to create a new feature branch from develop
# Usage: ./new-feature.sh feature-name

set -e

# Check if feature name was provided
if [ -z "$1" ]; then
  echo "Error: You must provide a feature name!"
  echo "Usage: ./new-feature.sh feature-name"
  exit 1
fi

FEATURE_NAME=$1

# Make sure we're on the develop branch first
git checkout develop

# Pull the latest changes from develop
git pull origin develop

# Create and switch to the new feature branch
git checkout -b "feature/$FEATURE_NAME"

echo "Created and switched to branch 'feature/$FEATURE_NAME'"
echo "Make your changes and then use: git add . && git commit -m 'Description'"
echo "When ready, push with: git push -u origin feature/$FEATURE_NAME"
echo "Then create a pull request from feature/$FEATURE_NAME to develop"

================
File: scripts/new-hotfix.bat
================
@echo off
REM Script to create a new hotfix branch from main
REM Usage: new-hotfix.bat hotfix-description

if "%~1"=="" (
  echo Error: You must provide a hotfix description!
  echo Usage: new-hotfix.bat hotfix-description
  exit /b 1
)

set HOTFIX_NAME=%~1

REM Make sure we're on the main branch first
git checkout main

REM Pull the latest changes from main
git pull origin main

REM Create and switch to the new hotfix branch
git checkout -b "hotfix/%HOTFIX_NAME%"

echo Created and switched to branch 'hotfix/%HOTFIX_NAME%'
echo Fix the issue and then use: git add . ^&^& git commit -m "Description"
echo When ready, push with: git push -u origin hotfix/%HOTFIX_NAME%
echo Then create a pull request from hotfix/%HOTFIX_NAME% to main
echo After merging to main, don't forget to merge back to develop:
echo git checkout develop ^&^& git pull ^&^& git merge hotfix/%HOTFIX_NAME% ^&^& git push

================
File: scripts/new-hotfix.sh
================
#!/bin/bash
# Script to create a new hotfix branch from main
# Usage: ./new-hotfix.sh hotfix-description

set -e

# Check if hotfix description was provided
if [ -z "$1" ]; then
  echo "Error: You must provide a hotfix description!"
  echo "Usage: ./new-hotfix.sh hotfix-description"
  exit 1
fi

HOTFIX_NAME=$1

# Make sure we're on the main branch first
git checkout main

# Pull the latest changes from main
git pull origin main

# Create and switch to the new hotfix branch
git checkout -b "hotfix/$HOTFIX_NAME"

echo "Created and switched to branch 'hotfix/$HOTFIX_NAME'"
echo "Fix the issue and then use: git add . && git commit -m 'Description'"
echo "When ready, push with: git push -u origin hotfix/$HOTFIX_NAME"
echo "Then create a pull request from hotfix/$HOTFIX_NAME to main"
echo "After merging to main, don't forget to merge back to develop:"
echo "git checkout develop && git pull && git merge hotfix/$HOTFIX_NAME && git push"

================
File: scripts/release.bat
================
@echo off
REM Script to promote code from develop to main (production)
REM Usage: release.bat [version]

REM Optional version parameter
set VERSION=%~1
if "%VERSION%"=="" (
  for /f "tokens=2-4 delims=/ " %%a in ('date /t') do (
    set VERSION=%%c.%%a.%%b
  )
)

echo Preparing release version %VERSION%...

REM Make sure develop branch is up to date
git checkout develop
git pull origin develop

REM Run tests
echo Running tests on develop branch...
cd ..\backend && npm test
cd ..\frontend && npm test
cd ..\scripts

REM If tests pass, switch to main and merge
git checkout main
git pull origin main

echo Merging develop into main...
git merge develop

REM Create a version tag
echo Creating version tag v%VERSION%...
git tag -a "v%VERSION%" -m "Release version %VERSION%"

REM Push changes
echo Pushing changes to remote repository...
git push origin main
git push origin "v%VERSION%"

echo Release v%VERSION% successfully created and pushed to main.
echo The production deployment workflow should start automatically.
echo Don't forget to switch back to the develop branch with: git checkout develop

================
File: scripts/release.sh
================
#!/bin/bash
# Script to promote code from develop to main (production)
# Usage: ./release.sh [version]

set -e

# Optional version parameter
VERSION=$1
if [ -z "$VERSION" ]; then
  VERSION=$(date "+%Y.%m.%d")
fi

echo "Preparing release version $VERSION..."

# Make sure develop branch is up to date
git checkout develop
git pull origin develop

# Run tests
echo "Running tests on develop branch..."
cd ../backend && npm test
cd ../frontend && npm test
cd ../scripts

# If tests pass, switch to main and merge
git checkout main
git pull origin main

echo "Merging develop into main..."
git merge develop

# Create a version tag
echo "Creating version tag v$VERSION..."
git tag -a "v$VERSION" -m "Release version $VERSION"

# Push changes
echo "Pushing changes to remote repository..."
git push origin main
git push origin "v$VERSION"

echo "Release v$VERSION successfully created and pushed to main."
echo "The production deployment workflow should start automatically."
echo "Don't forget to switch back to the develop branch with: git checkout develop"

================
File: backend/Dockerfile
================
FROM node:20.13-alpine

WORKDIR /usr/src/app

# Copy package.json and package-lock.json first for better cache
COPY package*.json ./

# Install dependencies
RUN npm ci

# Copy the rest of the code
COPY . .

# Build TypeScript code
RUN npm run build

# Remove dev dependencies
RUN npm prune --production

# Expose the application port
EXPOSE 5000

# Set environment variables
ENV NODE_ENV=production

# Run the application
CMD ["node", "dist/server.js"]

================
File: backend/package.json
================
{
  "name": "ala-backend",
  "version": "0.1.0",
  "private": true,
  "main": "dist/server.js",
  "scripts": {
    "start": "node dist/server.js",
    "dev": "nodemon src/server.ts",
    "build": "tsc",
    "lint": "eslint src --ext ts --fix",
    "test": "jest",
    "db:init": "ts-node src/dbInit.ts"
  },
  "dependencies": {
    "axios": "^1.5.0",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-async-handler": "^1.2.0",
    "helmet": "^7.0.0",
    "joi": "^17.9.2",
    "jsonwebtoken": "^9.0.0",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "pg": "^8.11.0",
    "pg-hstore": "^2.3.4",
    "sequelize": "^6.32.0",
    "twilio": "^4.11.0",
    "winston": "^3.9.0"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.2",
    "@types/cors": "^2.8.13",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.2",
    "@types/jsonwebtoken": "^9.0.2",
    "@types/morgan": "^1.9.4",
    "@types/multer": "^1.4.7",
    "@types/node": "^20.3.1",
    "@types/pg": "^8.10.2",
    "@types/supertest": "^2.0.12",
    "@typescript-eslint/eslint-plugin": "^5.59.11",
    "@typescript-eslint/parser": "^5.59.11",
    "eslint": "^8.43.0",
    "jest": "^29.5.0",
    "nodemon": "^2.0.22",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.0",
    "ts-node": "^10.9.1",
    "typescript": "^5.1.3"
  }
}

================
File: backend/src/models/User.ts
================
import { DataTypes, Model, Optional } from 'sequelize';
import sequelize from '../config/database';
import bcrypt from 'bcryptjs';

// User attributes interface
interface UserAttributes {
  id: string;
  name: string;
  email: string | null;
  phoneNumber: string | null;
  role: 'hospital' | 'alphatau' | 'admin';
  verificationCode: string | null;
  verificationExpires: Date | null;
  failedAttempts: number;
  lastLogin: Date | null;
  metadata: any; // New field to store Priority user data
}

// For creating a new user
interface UserCreationAttributes extends Optional<UserAttributes, 'id' | 'verificationCode' | 'verificationExpires' | 'failedAttempts' | 'lastLogin' | 'metadata'> {}

class User extends Model<UserAttributes, UserCreationAttributes> implements UserAttributes {
  public id!: string;
  public name!: string;
  public email!: string | null;
  public phoneNumber!: string | null;
  public role!: 'hospital' | 'alphatau' | 'admin';
  public verificationCode!: string | null;
  public verificationExpires!: Date | null;
  public failedAttempts!: number;
  public lastLogin!: Date | null;
  public metadata!: any;

  // Timestamps
  public readonly createdAt!: Date;
  public readonly updatedAt!: Date;

  // Helper methods
  public async generateVerificationCode(): Promise<string> {
    // TESTING ONLY: Use a fixed verification code "123456" for easier testing
    // In production, this should generate a random code and use a real SMS/email service
    const verificationCode = process.env.NODE_ENV === 'production' 
      ? Math.floor(100000 + Math.random() * 900000).toString() 
      : "123456"; // Fixed code for development and testing
    
    // Hash the verification code
    const hashedCode = await bcrypt.hash(verificationCode, 10);
    
    // Set expiration (10 minutes from now)
    const expiration = new Date();
    expiration.setMinutes(expiration.getMinutes() + 10);
    
    // Update user record
    this.verificationCode = hashedCode;
    this.verificationExpires = expiration;
    await this.save();
    
    return verificationCode;
  }

  public async verifyCode(code: string): Promise<boolean> {
    // Check if verification code exists and is not expired
    if (!this.verificationCode || !this.verificationExpires) {
      return false;
    }
    
    if (new Date() > this.verificationExpires) {
      // Clear expired code
      this.verificationCode = null;
      this.verificationExpires = null;
      await this.save();
      return false;
    }
    
    // Verify the code
    const isValid = await bcrypt.compare(code, this.verificationCode);
    
    if (isValid) {
      // Clear the code on successful verification
      this.verificationCode = null;
      this.verificationExpires = null;
      this.failedAttempts = 0;
      this.lastLogin = new Date();
      await this.save();
    } else {
      // Increment failed attempts
      this.failedAttempts += 1;
      await this.save();
    }
    
    return isValid;
  }
}

User.init(
  {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    email: {
      type: DataTypes.STRING,
      allowNull: true,
      unique: true,
      validate: {
        isEmail: true,
      },
    },
    phoneNumber: {
      type: DataTypes.STRING,
      allowNull: true,
      unique: true,
    },
    role: {
      type: DataTypes.ENUM('hospital', 'alphatau', 'admin'),
      allowNull: false,
      defaultValue: 'hospital',
    },
    verificationCode: {
      type: DataTypes.STRING,
      allowNull: true,
    },
    verificationExpires: {
      type: DataTypes.DATE,
      allowNull: true,
    },
    failedAttempts: {
      type: DataTypes.INTEGER,
      allowNull: false,
      defaultValue: 0,
    },
    lastLogin: {
      type: DataTypes.DATE,
      allowNull: true,
    },
    metadata: {
      type: DataTypes.JSON,
      allowNull: true,
      defaultValue: {},
    },
  },
  {
    sequelize,
    modelName: 'User',
    tableName: 'users',
    timestamps: true,
  }
);

export default User;

================
File: backend/src/routes/adminRoutes.ts
================
import express from 'express';
import { protect, restrict } from '../middleware/authMiddleware';

const router = express.Router();

// Protect all routes and restrict to admin role
router.use(protect, restrict('admin'));

// Dashboard statistics
router.get('/dashboard/stats', (req, res) => {
  // Mock implementation - in a real app, this would fetch actual statistics
  res.status(200).json({
    totalTreatments: 156,
    completedTreatments: 142,
    pendingTreatments: 14,
    totalApplicators: 843,
    users: 27,
  });
});

// System logs
router.get('/logs', (req, res) => {
  // Mock implementation - in a real app, this would fetch actual logs
  res.status(200).json({
    logs: [
      {
        timestamp: '2025-05-10T09:45:21Z',
        level: 'INFO',
        message: 'User logged in successfully',
        user: 'john.doe@example.com',
      },
      {
        timestamp: '2025-05-10T08:32:15Z',
        level: 'WARNING',
        message: 'Multiple verification attempts detected',
        user: 'sarah.smith@example.com',
      },
      {
        timestamp: '2025-05-09T17:12:53Z',
        level: 'ERROR',
        message: 'Failed to connect to Priority system',
        user: 'System',
      },
    ],
  });
});

// User management
router.get('/users', (req, res) => {
  // Mock implementation - in a real app, this would fetch actual users
  res.status(200).json({
    users: [
      {
        id: '1',
        name: 'John Doe',
        email: 'john.doe@example.com',
        role: 'hospital',
        lastLogin: '2025-05-10T09:45:21Z',
      },
      {
        id: '2',
        name: 'Sarah Smith',
        email: 'sarah.smith@example.com',
        role: 'alphatau',
        lastLogin: '2025-05-10T08:32:15Z',
      },
    ],
  });
});

// System configuration
router.get('/config', (req, res) => {
  res.status(200).json({
    priorityUrl: process.env.PRIORITY_URL,
    verificationCodeExpiry: 600, // 10 minutes
    maxFailedAttempts: 3,
    minDaysForRemoval: 14,
    maxDaysForRemoval: 20,
  });
});

router.put('/config', (req, res) => {
  // Mock implementation - in a real app, this would update system configuration
  res.status(200).json({
    message: 'Configuration updated successfully',
    config: req.body,
  });
});

export default router;

================
File: backend/src/routes/applicatorRoutes.ts
================
import express from 'express';
import {
  validateApplicator,
  getApplicatorById,
  getSeedStatus
} from '../controllers/applicatorController';
import { protect } from '../middleware/authMiddleware';

const router = express.Router();

// Protect all routes
router.use(protect);

// Applicator routes
router.post('/validate', validateApplicator);
router.get('/:id', getApplicatorById);
router.get('/treatment/:treatmentId/seed-status', getSeedStatus);

export default router;

================
File: backend/src/routes/treatmentRoutes.ts
================
import express from 'express';
import {
  getTreatments,
  getTreatmentById,
  createTreatment,
  updateTreatment,
  completeTreatment,
  getTreatmentApplicators,
  addApplicator,
  exportTreatment,
} from '../controllers/treatmentController';
import { updateApplicator } from '../controllers/applicatorController';
import { protect } from '../middleware/authMiddleware';

const router = express.Router();

// Protect all routes
router.use(protect);

// Treatment routes
router.route('/')
  .get(getTreatments)
  .post(createTreatment);

router.route('/:id')
  .get(getTreatmentById)
  .put(updateTreatment);

router.post('/:id/complete', completeTreatment);
router.get('/:id/export', exportTreatment);

// Treatment applicator routes
router.route('/:id/applicators')
  .get(getTreatmentApplicators)
  .post(addApplicator);

router.patch('/:treatmentId/applicators/:id', updateApplicator);

export default router;

================
File: docker-compose.dev.yml
================
services:
  # Backend API for development
  api:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    container_name: ala-api-dev
    restart: unless-stopped
    depends_on:
      - db
    environment:
      - NODE_ENV=development
      - PORT=5000
      - DATABASE_URL=postgres://postgres:postgres@db:5432/ala_db
      - ENABLE_SSL=false
      - JWT_SECRET=dev-jwt-secret-key
      - PRIORITY_URL=https://t.eu.priority-connect.online/odata/Priority/tabbtbc6.ini/test24/
      - PRIORITY_MOCK=true  # Enable mock responses for development
    ports:
      - "5000:5000"
    networks:
      - ala-network
    volumes:
      - ./backend:/usr/src/app
      - /usr/src/app/node_modules
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:5000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s

  # Frontend application for development
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    container_name: ala-frontend-dev
    restart: unless-stopped
    environment:
      - VITE_API_URL=http://localhost:5000/api
    ports:
      - "3000:3000"
    depends_on:
      - api
    networks:
      - ala-network
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s
    volumes:
      - ./frontend:/usr/src/app
      - /usr/src/app/node_modules

  # PostgreSQL Database
  db:
    image: postgres:15-alpine
    container_name: ala-db-dev
    restart: unless-stopped
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=ala_db
    ports:
      - "5432:5432"
    networks:
      - ala-network
    volumes:
      - postgres-data-dev:/var/lib/postgresql/data

networks:
  ala-network:
    driver: bridge

volumes:
  postgres-data-dev:

================
File: frontend/Dockerfile
================
# Build stage
FROM node:20.13-alpine AS build

WORKDIR /usr/src/app

# Copy package.json and package-lock.json
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the code
COPY . .

# Build the application
RUN npm run build

# Production stage
FROM nginx:stable-alpine

# Copy built assets from the build stage
COPY --from=build /usr/src/app/dist /usr/share/nginx/html

# Copy custom nginx config
COPY nginx.conf /etc/nginx/templates/default.conf.template

# Expose port 80
EXPOSE 80

# Use environment variables in nginx config
ENV NGINX_ENVSUBST_TEMPLATE_DIR=/etc/nginx/templates
ENV NGINX_ENVSUBST_OUTPUT_DIR=/etc/nginx/conf.d

CMD ["nginx", "-g", "daemon off;"]

================
File: frontend/Dockerfile.dev
================
FROM node:20.13-alpine

WORKDIR /usr/src/app

# Copy package.json and package-lock.json
COPY package*.json ./

# Install ALL dependencies including development dependencies
RUN npm install

# Copy the rest of the code
COPY . .

# Expose the development port
EXPOSE 3000

# Set environment variables
ENV NODE_ENV=development

# Command to run the development server
CMD ["npm", "run", "dev", "--", "--host", "0.0.0.0"]

================
File: frontend/nginx.conf
================
server {
    listen 80;
    root /usr/share/nginx/html;
    index index.html;

    # Gzip compression
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml text/javascript;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-XSS-Protection "1; mode=block";
    add_header X-Content-Type-Options "nosniff";
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data:; connect-src 'self' http://localhost:5000 http://api:5000 https://*.priority-connect.online https://*.azure-api.net https://*.azurewebsites.net";

    # Handle API requests by proxying to backend
    location /api/ {
        proxy_pass http://api:5000/api/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # Handle single page application
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Cache static assets
    location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
        expires 30d;
    }
}

================
File: frontend/src/App.tsx
================
import { Routes, Route, Navigate } from 'react-router-dom';

import { AuthProvider } from '@/context/AuthContext';
import { TreatmentProvider } from '@/context/TreatmentContext';
import ProtectedRoute from '@/components/ProtectedRoute';
import LoginPage from '@/pages/Auth/LoginPage';
import VerificationPage from '@/pages/Auth/VerificationPage';
import TreatmentSelection from '@/pages/Treatment/TreatmentSelection';
import ScanQRCode from '@/pages/Treatment/ScanQRCode';
import ApplicatorInformation from '@/pages/Treatment/ApplicatorInformation';
import UseList from '@/pages/Treatment/UseList';
import SeedRemoval from '@/pages/Treatment/SeedRemoval';
import Dashboard from '@/pages/Admin/Dashboard';
import ProjectDocPage from '@/pages/ProjectDocPage'; // Import the new page

function App() {
  return (
    <AuthProvider>
      <TreatmentProvider>
        <div className="min-h-screen bg-background">
          <Routes>
            <Route path="/login" element={<LoginPage />} />
            <Route path="/verify" element={<VerificationPage />} />
            <Route path="/docs" element={<ProjectDocPage />} /> {/* New docs page - accessible without login */}
            
            <Route element={<ProtectedRoute />}>
              <Route path="/treatment/select" element={<TreatmentSelection />} />
              <Route path="/treatment/scan" element={<ScanQRCode />} />
              <Route path="/treatment/applicator" element={<ApplicatorInformation />} />
              <Route path="/treatment/list" element={<UseList />} />
              <Route path="/treatment/removal" element={<SeedRemoval />} />
              <Route path="/admin/dashboard" element={<Dashboard />} />
            </Route>
            
            <Route path="/" element={<Navigate to="/login" replace />} />
            <Route path="*" element={<Navigate to="/login" replace />} />
          </Routes>
        </div>
      </TreatmentProvider>
    </AuthProvider>
  );
}

export default App;

================
File: frontend/src/components/Layout.tsx
================
import { ReactNode } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '@/context/AuthContext';

interface LayoutProps {
  children: ReactNode;
  title: string;
  showBackButton?: boolean;
  backPath?: string;
  showLogout?: boolean;
}

// Define the treatment flow sequence to enable sequential navigation
const TREATMENT_FLOW = [
  '/treatment/select',   // Treatment selection
  '/treatment/scan',     // Scan QR Code
  '/treatment/applicator', // Applicator information
  '/treatment/list',     // Use list
  '/treatment/removal'   // Seed removal
];

export default function Layout({ 
  children, 
  title, 
  showBackButton = false, 
  backPath = '', 
  showLogout = true 
}: LayoutProps) {
  const navigate = useNavigate();
  const { user, logout } = useAuth();
  
  const handleBack = () => {
    if (backPath) {
      navigate(backPath);
    } else {
      navigate(-1);
    }
  };
  
  // Helper function to navigate through the treatment flow
  const navigateSequential = (direction: 'next' | 'prev') => {
    const currentPath = window.location.pathname;
    const currentIndex = TREATMENT_FLOW.indexOf(currentPath);
    
    if (currentIndex !== -1) {
      // If we're in the treatment flow
      const newIndex = direction === 'next' 
        ? Math.min(currentIndex + 1, TREATMENT_FLOW.length - 1)
        : Math.max(currentIndex - 1, 0);
      
      if (newIndex !== currentIndex) {
        navigate(TREATMENT_FLOW[newIndex]);
      }
    } else {
      // If we're not in the treatment flow, use browser history
      navigate(direction === 'next' ? 1 : -1);
    }
  };

  return (
    <div className="flex min-h-screen flex-col">
      <header className="bg-primary p-4 text-white shadow-md">
        <div className="container mx-auto flex items-center justify-between">
          {/* Left section - Title with back button */}
          <div className="flex items-center gap-2">
            {showBackButton && (
              <button
                onClick={handleBack}
                className="rounded-full p-2 hover:bg-primary-foreground/10"
                title="Back to specified path"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  className="h-6 w-6"
                >
                  <path d="m15 18-6-6 6-6" />
                </svg>
              </button>
            )}
            <h1 className="text-xl font-bold">{title}</h1>
          </div>
          
          {/* Middle section - Debug navigation */}
          <div className="flex flex-col items-center">
            {/* Flow position indicator */}
            <div className="mb-1 text-xs text-white/70">
              {TREATMENT_FLOW.indexOf(window.location.pathname) !== -1 && (
                <span>
                  Step {TREATMENT_FLOW.indexOf(window.location.pathname) + 1}/{TREATMENT_FLOW.length}
                </span>
              )}
            </div>
            <div className="flex items-center gap-1">
              <button
                onClick={() => navigateSequential('prev')}
                className="flex items-center justify-center rounded-md bg-primary-foreground/10 px-3 py-2 text-sm font-medium hover:bg-primary-foreground/20"
                title="Previous screen (for debugging)"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="16"
                  height="16"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  className="mr-1"
                >
                  <path d="m15 18-6-6 6-6" />
                </svg>
                Prev
              </button>
              <button
                onClick={() => navigateSequential('next')}
                className="flex items-center justify-center rounded-md bg-primary-foreground/10 px-3 py-2 text-sm font-medium hover:bg-primary-foreground/20"
                title="Next screen (for debugging)"
              >
                Next
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="16"
                  height="16"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  className="ml-1"
                >
                  <path d="m9 18 6-6-6-6" />
                </svg>
              </button>
            </div>
          </div>
          
          {/* Right section - User info and logout */}
          <div className="flex items-center gap-4">
            {user && (
              <div className="text-sm">
                <span className="text-white/80">User: </span>
                <span className="font-semibold">{user.name}</span>
              </div>
            )}
            {showLogout && (
              <button
                onClick={logout}
                className="rounded-md bg-primary-foreground/10 px-3 py-1 text-sm hover:bg-primary-foreground/20"
              >
                Logout
              </button>
            )}
          </div>
        </div>
      </header>

      <main className="container mx-auto flex-1 p-4">
        {children}
      </main>

      <footer className="border-t bg-secondary p-4 text-center text-sm text-muted-foreground">
        <p>&copy; {new Date().getFullYear()} AlphaTau Medical Ltd. All rights reserved.</p>
      </footer>
    </div>
  );
}

================
File: frontend/src/pages/Auth/VerificationPage.tsx
================
import { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '@/context/AuthContext';
import { authService } from '@/services/authService';

const VerificationPage = () => {
  const { verify, error, clearError, isLoading } = useAuth();
  const [code, setCode] = useState('');
  const [remainingTime, setRemainingTime] = useState(10); // 10 seconds timeout
  const [resendDisabled, setResendDisabled] = useState(true);
  const navigate = useNavigate();
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  // Start countdown for resend button
  useEffect(() => {
    timerRef.current = setInterval(() => {
      setRemainingTime((prev) => {
        if (prev <= 1) {
          setResendDisabled(false);
          if (timerRef.current) clearInterval(timerRef.current);
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => {
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (code) {
      await verify(code);
    }
  };

  const handleResendCode = async () => {
    try {
      // Get the identifier from local storage or session
      const identifier = sessionStorage.getItem('loginIdentifier');
      if (!identifier) {
        // If not found, go back to login
        navigate('/login');
        return;
      }

      await authService.resendVerificationCode(identifier);
      
      // Reset timer
      setRemainingTime(10);
      setResendDisabled(true);
      
      // Restart timer
      if (timerRef.current) clearInterval(timerRef.current);
      timerRef.current = setInterval(() => {
        setRemainingTime((prev) => {
          if (prev <= 1) {
            setResendDisabled(false);
            if (timerRef.current) clearInterval(timerRef.current);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
      
    } catch (err) {
      console.error('Failed to resend code:', err);
    }
  };

  return (
    <div className="flex min-h-screen flex-col items-center justify-center bg-gray-50 p-4">
      <div className="w-full max-w-md">
        <div className="mb-8 text-center">
          <img 
            src="C:\Users\amitaik\Desktop\ala-improved\frontend\src\alphataulogo.png" 
            alt="AlphaTau Logo" 
            className="mx-auto mb-4 h-16 w-auto"
          />
          <h1 className="text-2xl font-bold text-gray-900">
            Verification Code
          </h1>
          <p className="mt-2 text-gray-600">
            Enter the verification code sent to your email or phone
          </p>
        </div>

        {error && (
          <div className="mb-4 rounded-md bg-red-50 p-4 text-sm text-red-700">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                  <path
                    fillRule="evenodd"
                    d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                    clipRule="evenodd"
                  />
                </svg>
              </div>
              <div className="ml-3">
                <p>{error}</p>
              </div>
              <div className="ml-auto pl-3">
                <div className="-mx-1.5 -my-1.5">
                  <button
                    onClick={clearError}
                    className="inline-flex rounded-md p-1.5 text-red-500 hover:bg-red-100 focus:outline-none"
                  >
                    <span className="sr-only">Dismiss</span>
                    <svg className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                      <path
                        fillRule="evenodd"
                        d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                        clipRule="evenodd"
                      />
                    </svg>
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label
              htmlFor="code"
              className="block text-sm font-medium text-gray-700"
            >
              Verification Code
            </label>
            <div className="mt-1">
              <input
                id="code"
                name="code"
                type="text"
                autoComplete="one-time-code"
                required
                value={code}
                onChange={(e) => setCode(e.target.value)}
                className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-primary focus:outline-none focus:ring-primary sm:text-sm"
              />
            </div>
          </div>

          <div className="flex flex-col space-y-4">
            <button
              type="submit"
              disabled={isLoading || !code}
              className="flex w-full justify-center rounded-md border border-transparent bg-primary px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 disabled:opacity-50"
            >
              {isLoading ? (
                <>
                  <svg className="mr-2 h-4 w-4 animate-spin" viewBox="0 0 24 24">
                    <circle
                      className="opacity-25"
                      cx="12"
                      cy="12"
                      r="10"
                      stroke="currentColor"
                      strokeWidth="4"
                    ></circle>
                    <path
                      className="opacity-75"
                      fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    ></path>
                  </svg>
                  Verifying...
                </>
              ) : (
                'Verify Code'
              )}
            </button>
            
            <button
              type="button"
              disabled={resendDisabled}
              onClick={handleResendCode}
              className="text-sm font-medium text-primary hover:text-primary/80 disabled:text-gray-400"
            >
              {resendDisabled
                ? `Resend code in ${remainingTime}s`
                : 'Resend verification code'}
            </button>
            
            <button
              type="button"
              onClick={() => navigate('/login')}
              className="text-sm font-medium text-gray-600 hover:text-gray-900"
            >
              Back to login
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default VerificationPage;

================
File: frontend/src/services/priorityService.ts
================
import api from './api';
import { Treatment } from './treatmentService';

// We'll use our backend API as a proxy to the Priority system
export const priorityService = {
  // Debug function to test Priority API connectivity
  async debugPriorityConnection(): Promise<any> {
    try {
      // Use our backend as a proxy to Priority
      const response = await api.get('/proxy/priority/debug');
      return response.data;
    } catch (error) {
      console.error('Priority API connection test failed:', error);
      return {
        success: false,
        error: error.message,
        details: error.response ? error.response.data : null
      };
    }
  },
  
  // Get treatments from Priority system
  async getTreatments(params: {
    type?: 'insertion' | 'removal';
    subjectId?: string;
    site?: string;
    date?: string;
  }): Promise<Treatment[]> {
    try {
      // Use our backend as a proxy to Priority
      const response = await api.get('/proxy/priority/treatments', { params });

      // Cache treatments for offline use
      localStorage.setItem('cached_treatments', JSON.stringify(response.data));

      return response.data;
    } catch (error) {
      console.error('Error fetching from Priority:', error);
      // Try to get from cache if available
      const cachedData = localStorage.getItem('cached_treatments');
      if (cachedData) {
        return JSON.parse(cachedData);
      }
      throw error;
    }
  },

  // Get all contacts from Priority PHONEBOOK
  async getContacts(): Promise<any[]> {
    const response = await api.get('/proxy/priority/contacts');
    return response.data;
  },

  // Get orders for a specific CUSTNAME (site)
  async getOrdersForSite(custName: string): Promise<any[]> {
    const response = await api.get(`/proxy/priority/orders`, {
      params: { custName }
    });
    return response.data;
  },

  // Get allowed sites for user based on POSITIONCODE and CUSTNAME
  async getAllowedSitesForUser(userPositionCode: string, userCustName: string): Promise<any[]> {
    const response = await api.get('/proxy/priority/allowed-sites', {
      params: { userPositionCode, userCustName }
    });
    return response.data;
  },
};

================
File: frontend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "node",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "jsxImportSource": "react",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

================
File: frontend/vite.config.ts
================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
    },
  },
  server: {
    host: '0.0.0.0', // This is critical for Docker - allows connections from outside the container
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://api:5000', // Use the Docker service name, not localhost
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
      },
    },
  },
});

================
File: backend/Dockerfile.dev
================
FROM node:20.13-alpine

WORKDIR /usr/src/app

# Copy package.json and package-lock.json first for better caching
COPY package*.json ./

# Install ALL dependencies including development dependencies
RUN npm install 
RUN npm install -g nodemon ts-node

# Copy the rest of the code
COPY . .

# Expose the application port
EXPOSE 5000

# Set environment variables
ENV NODE_ENV=development

# Run the development server
CMD ["npm", "run", "dev"]

================
File: backend/src/server.ts
================
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import dotenv from 'dotenv';
import { errorHandler } from './middleware/errorMiddleware';
import { notFound } from './middleware/notFoundMiddleware';
import authRoutes from './routes/authRoutes';
import treatmentRoutes from './routes/treatmentRoutes';
import applicatorRoutes from './routes/applicatorRoutes';
import adminRoutes from './routes/adminRoutes';
import priorityRoutes from './routes/priorityRoutes';
import { initializeDatabase } from './config/database';
import logger from './utils/logger';

// Load environment variables
dotenv.config();

// Initialize express app
const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cors());
app.use(helmet());
app.use(morgan('dev'));

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.status(200).json({
    status: 'ok',
    message: 'Server is running',
    version: '0.1.0',
    timestamp: new Date().toISOString(),
    env: process.env.NODE_ENV
  });
});

// Debug endpoint to check API routes
app.get('/api/routes', (req, res) => {
  const routes: Array<{path: string, methods: string[]}> = [];
  
  // Get registered routes
  app._router.stack.forEach((middleware: any) => {
    if(middleware.route){ // Routes registered directly on the app
      routes.push({
        path: middleware.route.path,
        methods: Object.keys(middleware.route.methods)
      });
    } else if(middleware.name === 'router'){ // Router middleware
      middleware.handle.stack.forEach((handler: any) => {
        if(handler.route){
          const path = handler.route.path;
          const methods = Object.keys(handler.route.methods);
          routes.push({ path: middleware.regexp.toString() + path, methods });
        }
      });
    }
  });
  
  res.status(200).json({
    routes,
    authRoutes: '/api/auth/*',
    treatmentRoutes: '/api/treatments/*',
    applicatorRoutes: '/api/applicators/*',
    adminRoutes: '/api/admin/*',
    priorityRoutes: '/api/proxy/priority/*'
  });
});

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/treatments', treatmentRoutes);
app.use('/api/applicators', applicatorRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/proxy/priority', priorityRoutes);

// 404 handler
app.use(notFound);

// Error handler
app.use(errorHandler);

// Initialize database and start server
const startServer = async () => {
  try {
    await initializeDatabase();
    app.listen(PORT, () => {
      logger.info(`Server running on port ${PORT}`);
    });
  } catch (error) {
    logger.error(`Failed to start server: ${error}`);
    process.exit(1);
  }
};

startServer();

export default app;

================
File: backend/src/services/priorityService.ts
================
import axios from 'axios';
import logger from '../utils/logger';

// Priority API credentials
const PRIORITY_URL =
  process.env.PRIORITY_URL ||
  'https://t.eu.priority-connect.online/odata/Priority/tabbtbc6.ini/test24/';
const PRIORITY_USERNAME = process.env.PRIORITY_USERNAME || 'API';
const PRIORITY_PASSWORD = process.env.PRIORITY_PASSWORD || 'Ap@123456';

// Create axios instance with authentication
const priorityApi = axios.create({
  baseURL: PRIORITY_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  auth: {
    username: PRIORITY_USERNAME,
    password: PRIORITY_PASSWORD,
  },
});

export const priorityService = {
  // Debugging Priority connection
  async debugPriorityConnection() {
    try {
      // Test basic connectivity
      logger.info('Testing connection to Priority API at:', PRIORITY_URL);
      const phonebookResponse = await priorityApi.get(`/PHONEBOOK`, {
        timeout: 10000, // 10 second timeout
      });
      logger.info('Connected to Priority API PHONEBOOK endpoint successfully');
      logger.info('Number of contacts:', phonebookResponse.data.value.length);
      
      if (phonebookResponse.data.value.length > 0) {
        logger.info('Sample contact data:', phonebookResponse.data.value[0]);
      }
      
      // Test ORDERS endpoint with a sample customer
      const ordersResponse = await priorityApi.get(`/ORDERS?$filter=CUSTNAME eq '100078'`, {
        timeout: 10000,
      });
      logger.info('ORDERS endpoint successful');
      logger.info('Number of orders:', ordersResponse.data.value.length);
      
      if (ordersResponse.data.value.length > 0) {
        logger.info('Sample order data:', ordersResponse.data.value[0]);
      }
      
      return {
        success: true,
        phonebookCount: phonebookResponse.data.value.length,
        phonebookSample: phonebookResponse.data.value.length > 0 ? phonebookResponse.data.value[0] : null,
        ordersCount: ordersResponse.data.value.length,
        ordersSample: ordersResponse.data.value.length > 0 ? ordersResponse.data.value[0] : null
      };
    } catch (error) {
      logger.error('Priority API connection test failed:', error);
      return {
        success: false,
        error: typeof error === 'object' && error !== null && 'message' in error ? (error as any).message : String(error),
        details: typeof error === 'object' && error !== null && 'response' in error && (error as any).response ? (error as any).response.data : null
      };
    }
  },
  
  // Get user site permissions
  async getUserSiteAccess(identifier: string) {
    // Always treat identifier as string
    identifier = String(identifier).trim();
    // For testing/development, if identifier contains '475', return a hardcoded successful response
    if (identifier === '475' || identifier.includes('475')) {
      logger.info('Using test data for user 475');
      return {
        found: true,
        fullAccess: false,
        sites: ['100078'],
        user: {
          email: 'test@example.com',
          phone: '475',
          positionCode: 50,
        },
      };
    }
    try {
      // Search by email or phone
      const isEmail = identifier.includes('@');
      let filterQuery = '';
      if (isEmail) {
        filterQuery = `EMAIL eq '${identifier}'`;
      } else {
        filterQuery = `PHONE eq ${Number(identifier)}`;
      }
      const response = await priorityApi.get('/PHONEBOOK', {
        params: {
          $filter: filterQuery,
          $select: 'CUSTNAME,POSITIONCODE,EMAIL,PHONE',
        },
      });
      if (response.data.value.length === 0) {
        logger.warn(
          `[Priority] No user found for identifier '${identifier}'. Full response: ${JSON.stringify(
            response.data
          )}`
        );
        return { found: false, sites: [] };
      }
      const user = response.data.value[0];
      
      // Always convert positionCode to a number to avoid type mismatches
      const positionCode = parseInt(user.POSITIONCODE, 10) || 0;

      // Check if user has full access (Alpha Tau employee)
      if (positionCode === 99) {
        // Return all sites (fetch them all)
        const sitesResponse = await priorityApi.get('/PHONEBOOK', {
          params: {
            $select: 'CUSTNAME',
            $orderby: 'CUSTNAME',
          },
        });

        // Extract unique sites
        const uniqueSites = [
          ...new Set(sitesResponse.data.value.map((item: any) => item.CUSTNAME)),
        ];

        return {
          found: true,
          fullAccess: true,
          sites: uniqueSites,
          user: {
            email: user.EMAIL,
            phone: user.PHONE,
            positionCode: positionCode,  // Use the parsed numeric value
          },
        };
      } else {
        // Return only the site the user is associated with
        return {
          found: true,
          fullAccess: false,
          sites: [user.CUSTNAME],
          user: {
            email: user.EMAIL,
            phone: user.PHONE,
            positionCode: positionCode,  // Use the parsed numeric value
          },
        };
      }
    } catch (error: any) {
      logger.error(`Error getting user site access: ${error}`);

      // Enhanced error handling
      if (error.response) {
        // The request was made and the server responded with a status code outside of 2xx
        logger.error(
          `Priority API error: ${error.response.status} - ${JSON.stringify(error.response.data)}`
        );

        // If the user is trying '475' which we know should work, provide fallback data
        if (identifier === '475' || identifier.includes('475')) {
          logger.info('Using fallback data for user 475 after API error');
          return {
            found: true,
            fullAccess: false,
            sites: ['100078'],
            user: {
              email: 'test@example.com',
              phone: '475',
              positionCode: 50,
            },
          };
        }
      } else if (error.request) {
        // The request was made but no response was received
        logger.error('Priority API request made but no response received');
      } else {
        // Something happened in setting up the request
        logger.error(`Priority API setup error: ${error.message}`);
      }

      throw new Error(`Failed to get user site access: ${error.message || error}`);
    }
  },

  // Get treatments for specified sites
  async getTreatmentsForSites(sites: string[], params: any) {
    try {
      const allTreatments = [];

      // For each site, get treatments
      for (const site of sites) {
        const orderFilter = `CUSTNAME eq '${site}'`;

        const response = await priorityApi.get('/ORDERS', {
          params: {
            $filter: orderFilter,
            $select: 'ORDNAME,CUSTNAME,ORDNAME,CURDATE,REFERENCE',
          },
        });

        // Map to our treatment format
        const siteTreatments = response.data.value.map((item: any) => ({
          id: item.ORDNAME,
          type: params.type || 'insertion',
          subjectId: item.REFERENCE || 'Unknown',
          site: item.CUSTNAME,
          date: item.CURDATE || new Date().toISOString().split('T')[0],
          isComplete: false,
        }));

        allTreatments.push(...siteTreatments);
      }

      // Apply any additional filtering
      return this.filterTreatments(allTreatments, params);
    } catch (error) {
      logger.error(`Error getting treatments for sites: ${error}`);
      throw new Error(`Failed to get treatments: ${error}`);
    }
  },

  // Filter treatments based on params
  filterTreatments(treatments: any[], params: any) {
    let filtered = [...treatments];

    if (params.subjectId) {
      filtered = filtered.filter((t) => t.subjectId.includes(params.subjectId));
    }

    if (params.date) {
      const paramDate = new Date(params.date).toISOString().split('T')[0];
      filtered = filtered.filter((t) => {
        const treatmentDate = new Date(t.date).toISOString().split('T')[0];
        return treatmentDate === paramDate;
      });
    }

    // Apply treatment date rules for 'removal' type
    if (params.type === 'removal') {
      const today = new Date();
      filtered = filtered.filter((t) => {
        const treatmentDate = new Date(t.date);
        const daysSinceInsertion = Math.floor(
          (today.getTime() - treatmentDate.getTime()) / (1000 * 60 * 60 * 24)
        );
        return daysSinceInsertion >= 14 && daysSinceInsertion <= 20;
      });
    }

    return filtered;
  },

  // Send treatment data to Priority
  async updatePriorityWithTreatment(treatmentData: any) {
    try {
      // Map treatment data to Priority format
      const priorityData = {
        CUSTNAME: treatmentData.site,
        REFERENCE: treatmentData.subjectId,
        CURDATE: new Date(treatmentData.date).toISOString(),
        // Map other fields as needed
      };

      // For a new treatment
      if (!treatmentData.priorityId) {
        const response = await priorityApi.post('/ORDERS', priorityData);
        return {
          success: true,
          priorityId: response.data.ORDNAME,
          message: 'Treatment created in Priority system',
        };
      }
      // For updating an existing treatment
      else {
        const response = await priorityApi.patch(
          `/ORDERS(ORDNAME='${treatmentData.priorityId}')`,
          priorityData
        );
        return {
          success: true,
          priorityId: treatmentData.priorityId,
          message: 'Treatment updated in Priority system',
        };
      }
    } catch (error) {
      logger.error(`Error updating Priority: ${error}`);
      throw new Error(`Failed to update Priority system: ${error}`);
    }
  },
};

export default priorityService;

================
File: frontend/src/services/authService.ts
================
import api from './api';

export interface AuthResponse {
  user: {
    id: string;
    email: string;
    phoneNumber: string;
    role: 'hospital' | 'alphatau' | 'admin';
    name: string;
    positionCode?: string;
    custName?: string;
  };
  token: string;
}

export const authService = {
  // Request verification code via SMS or email
  async requestVerificationCode(identifier: string): Promise<{
    success: boolean;
    message?: string;
    userData?: {
      name: string;
      email: string;
      phoneNumber: string;
      positionCode: string;
      custName: string;
    };
  }> {
    try {
      // The backend will validate emails with Priority
      const response = await api.post('/auth/request-code', { identifier });
      
      return {
        success: true,
        message: 'Verification code sent',
        userData: response.data.userData
      };
    } catch (error: any) {
      console.error('Error requesting verification code:', error);
      
      return {
        success: false,
        message: error.response?.data?.message || error.message || 'Failed to request verification code'
      };
    }
  },

  // Verify the code and get authentication token
  async verifyCode(identifier: string, code: string): Promise<AuthResponse> {
    const response = await api.post<AuthResponse>('/auth/verify', {
      identifier,
      code,
    });
    
    return response.data;
  },

  // Validate token with the backend
  async validateToken(token: string): Promise<boolean> {
    try {
      const response = await api.post('/auth/validate-token', {}, {
        headers: { Authorization: `Bearer ${token}` },
      });
      return response.status === 200;
    } catch (error) {
      return false;
    }
  },

  // Request a resend of the verification code
  async resendVerificationCode(identifier: string): Promise<void> {
    await api.post('/auth/resend-code', { identifier });
  }
};

================
File: README.md
================
# Accountability Log Application (ALA)

A comprehensive application for tracking medical treatments, applicator usage, and seed management with a focus on reliability and user experience.

##  Project Structure

```
ala-improved/
 .env.docker
 .gitignore
 azure/
    azure-deploy.sh
    deploy.ps1
    README.md
 backend/
    Dockerfile
    package.json
    src/
       config/
          database.ts
       controllers/
          authController.ts
       middleware/
          authMiddleware.ts
          errorMiddleware.ts
          notFoundMiddleware.ts
       models/
          Applicator.ts
          index.ts
          Treatment.ts
          User.ts
       routes/
          adminRoutes.ts
          applicatorRoutes.ts
          authRoutes.ts
          treatmentRoutes.ts
       utils/
          logger.ts
       seedUser.js
       seedUser.ts
       server.ts
    tsconfig.json
 debug.bat
 debug.sh
 docker-compose.dev.yml
 docker-compose.prod.yml
 docker-compose.yml
 docs/
    IMPROVEMENTS.md
 frontend/
    Dockerfile
    Dockerfile.dev
    index.html
    nginx.conf
    package.json
    postcss.config.js
    src/
       App.tsx
       components/
          FileExplorer.tsx
          Layout.tsx
          ProtectedRoute.tsx
       context/
          AuthContext.tsx
          TreatmentContext.tsx
       index.css
       main.tsx
       pages/
          Admin/
             Dashboard.tsx
          Auth/
             LoginPage.tsx
             VerificationPage.tsx
          Treatment/
             ApplicatorInformation.tsx
             ScanQRCode.tsx
             SeedRemoval.tsx
             TreatmentSelection.tsx
             UseList.tsx
          ProjectDocPage.tsx
       services/
           api.ts
           authService.ts
           priorityService.ts
           treatmentService.ts
    tailwind.config.js
    tsconfig.json
    tsconfig.node.json
    vite.config.ts
 README.md
 restart.bat
 scripts/
     debug.js
```

##  Features

- **Secure Authentication**: Verification code-based login via SMS/email
- **Treatment Management**: Track and document medical treatments
- **Barcode Scanning**: Scan applicator barcodes with validation
- **Offline Support**: Continue working without network connectivity
- **Reporting**: Generate treatment reports in CSV/PDF formats
- **Admin Dashboard**: Monitor system usage and manage configurations
- **Priority Integration**: Seamless connection to the Priority system

##  Technology Stack

### Backend
- Node.js with Express
- TypeScript
- Sequelize ORM
- PostgreSQL
- JWT authentication
- Winston for logging

### Frontend
- React 18
- TypeScript
- Tailwind CSS
- Vite
- Context API for state management
- React Router for navigation

### DevOps
- Docker & Docker Compose
- Azure Container Registry
- Azure App Service
- Azure Database for PostgreSQL

##  Getting Started

### Development Mode

```bash
# Clone the repository
git clone https://github.com/AT2024/ALA.git
cd ALA

# Start the development environment
docker-compose -f docker-compose.dev.yml up -d

# Access the application
# Frontend: http://localhost:3000
# Backend API: http://localhost:5000
# Documentation: http://localhost:3000/docs
```

### Production Mode

```bash
# Start the production environment
docker-compose -f docker-compose.prod.yml up -d
```

### Debugging

```bash
# Run the debug script
./debug.bat  # Windows
./debug.sh   # Linux/Mac

# Restart containers
./restart.bat
```

##  Recent Updates

- Fixed API path inconsistencies in authentication service
- Enhanced Priority system integration
- Added comprehensive debugging tools
- Improved error handling and TypeScript type safety
- Added project documentation with visual file explorer

##  Integration with Priority

The application integrates with the Priority system using the following endpoints:
- `/PHONEBOOK` - For contact information
- `/ORDERS` - For treatment data

Position code '99' grants access to all treatment sites, while other codes restrict users to their assigned sites.

##  Debugging Tools

The application includes several debugging utilities:
- `debug.bat`/`debug.sh` - Test connectivity to backend and Priority APIs
- `scripts/debug.js` - Detailed diagnostic script
- `restart.bat` - Restart Docker containers
- Project documentation page at `/docs`

##  Documentation

Access the built-in documentation by navigating to `/docs` in the running application. The documentation includes:
- File structure visualization
- Recent changes
- Running instructions
- Debugging tips

##  License

Proprietary - All rights reserved

================
File: backend/src/controllers/authController.ts
================
import { Request, Response } from 'express';
import asyncHandler from 'express-async-handler';
import jwt from 'jsonwebtoken';
import { User } from '../models';
import logger from '../utils/logger';

// JWT Secret from environment variables
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Generate JWT token
const generateToken = (id: string) => {
  return jwt.sign({ id }, JWT_SECRET, {
    expiresIn: '30d',
  });
};

// @desc    Request verification code
// @route   POST /api/auth/request-code
// @access  Public
export const requestVerificationCode = asyncHandler(async (req: Request, res: Response) => {
  const { identifier } = req.body;

  if (!identifier) {
    res.status(400);
    throw new Error('Email or phone number is required');
  }

  // Check if the identifier is an email or phone number
  const isEmail = identifier.includes('@');
  
  // Find the user by email or phone number
  let user;
  if (isEmail) {
    user = await User.findOne({ where: { email: identifier } });
  } else {
    user = await User.findOne({ where: { phoneNumber: identifier } });
  }

  // If user not found, create a test user for demo purposes
  if (!user) {
    // This is for demo purposes only - in production, validate against a real system
    if (identifier === 'tzufitc@alphatau.com' || identifier === 'test@example.com') {
      user = await User.create({
        name: identifier === 'tzufitc@alphatau.com' ? 'TzufitC' : 'Test User',
        email: identifier,
        phoneNumber: null,
        role: 'admin',
        metadata: {
          positionCode: '99',
          custName: '100078'
        }
      });
      logger.info(`Created test user: ${user.id}`);
    } else {
      res.status(404);
      throw new Error('User not found');
    }
  }

  // Generate verification code
  const verificationCode = await user.generateVerificationCode();

  // In a real app, send the code via SMS or email
  // For demo purposes, we'll just log it
  logger.info(`Verification code for ${identifier}: ${verificationCode}`);

  res.status(200).json({
    success: true,
    message: 'Verification code sent',
  });
});

// @desc    Verify code and login
// @route   POST /api/auth/verify
// @access  Public
export const verifyCode = asyncHandler(async (req: Request, res: Response) => {
  const { identifier, code } = req.body;

  if (!identifier || !code) {
    res.status(400);
    throw new Error('Email/phone and verification code are required');
  }

  // Check if the identifier is an email or phone number
  const isEmail = identifier.includes('@');
  
  // Find the user by email or phone number
  let user;
  if (isEmail) {
    user = await User.findOne({ where: { email: identifier } });
  } else {
    user = await User.findOne({ where: { phoneNumber: identifier } });
  }

  if (!user) {
    res.status(404);
    throw new Error('User not found');
  }

  // Verify the code
  const isValid = await user.verifyCode(code);

  if (!isValid) {
    // Check if failed attempts exceed limit
    if (user.failedAttempts >= 3) {
      // In a real app, notify admin
      logger.warn(`User ${identifier} exceeded verification attempts limit`);
    }
    
    res.status(401);
    throw new Error('Invalid verification code');
  }

  // Generate JWT token
  const token = generateToken(user.id);

  res.status(200).json({
    success: true,
    user: {
      id: user.id,
      name: user.name,
      email: user.email,
      phoneNumber: user.phoneNumber,
      role: user.role,
      metadata: user.metadata
    },
    token,
  });
});

// @desc    Resend verification code
// @route   POST /api/auth/resend-code
// @access  Public
export const resendVerificationCode = asyncHandler(async (req: Request, res: Response) => {
  const { identifier } = req.body;

  if (!identifier) {
    res.status(400);
    throw new Error('Email or phone number is required');
  }

  // Check if the identifier is an email or phone number
  const isEmail = identifier.includes('@');
  
  // Find the user by email or phone number
  let user;
  if (isEmail) {
    user = await User.findOne({ where: { email: identifier } });
  } else {
    user = await User.findOne({ where: { phoneNumber: identifier } });
  }

  if (!user) {
    res.status(404);
    throw new Error('User not found');
  }

  // Generate verification code
  const verificationCode = await user.generateVerificationCode();

  // In a real app, send the code via SMS or email
  // For demo purposes, we'll just log it
  logger.info(`Verification code for ${identifier}: ${verificationCode}`);

  res.status(200).json({
    success: true,
    message: 'Verification code resent',
  });
});

// @desc    Validate token
// @route   POST /api/auth/validate-token
// @access  Private
export const validateToken = asyncHandler(async (req: Request, res: Response) => {
  // If the request made it past the protect middleware, the token is valid
  res.status(200).json({
    success: true,
    message: 'Token is valid',
    user: {
      id: req.user.id,
      name: req.user.name,
      email: req.user.email,
      phoneNumber: req.user.phoneNumber,
      role: req.user.role,
      metadata: req.user.metadata
    },
  });
});




================================================================
End of Codebase
================================================================
